Directory structure:
â””â”€â”€ darrenhinde-opencode-plugin-starter/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ config.json
    â”œâ”€â”€ package.json
    â”œâ”€â”€ tsconfig.json
    â”œâ”€â”€ context/
    â”‚   â”œâ”€â”€ context-overview.md
    â”‚   â”œâ”€â”€ architecture/
    â”‚   â”‚   â”œâ”€â”€ lifecycle.md
    â”‚   â”‚   â””â”€â”€ overview.md
    â”‚   â”œâ”€â”€ capabilities/
    â”‚   â”‚   â”œâ”€â”€ agents.md
    â”‚   â”‚   â”œâ”€â”€ events.md
    â”‚   â”‚   â”œâ”€â”€ events_skills.md
    â”‚   â”‚   â””â”€â”€ tools.md
    â”‚   â””â”€â”€ reference/
    â”‚       â””â”€â”€ best-practices.md
    â”œâ”€â”€ my-little-ui/
    â”‚   â”œâ”€â”€ package.json
    â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â””â”€â”€ src/
    â”‚       â”œâ”€â”€ index.ts
    â”‚       â”œâ”€â”€ plugin-info.ts
    â”‚       â”œâ”€â”€ agents/
    â”‚       â”‚   â”œâ”€â”€ index.ts
    â”‚       â”‚   â””â”€â”€ my-helper-agent.ts
    â”‚       â”œâ”€â”€ components/
    â”‚       â”‚   â”œâ”€â”€ banner.ts
    â”‚       â”‚   â””â”€â”€ banners.ts
    â”‚       â”œâ”€â”€ hooks/
    â”‚       â”‚   â”œâ”€â”€ index.ts
    â”‚       â”‚   â””â”€â”€ tool-hooks.ts
    â”‚       â”œâ”€â”€ lifecycle/
    â”‚       â”‚   â”œâ”€â”€ index.ts
    â”‚       â”‚   â””â”€â”€ on-session-created.ts
    â”‚       â”œâ”€â”€ tools/
    â”‚       â”‚   â”œâ”€â”€ index.ts
    â”‚       â”‚   â”œâ”€â”€ plugin-info.ts
    â”‚       â”‚   â”œâ”€â”€ quick-shell.ts
    â”‚       â”‚   â”œâ”€â”€ say-hello.ts
    â”‚       â”‚   â””â”€â”€ view-logs.ts
    â”‚       â””â”€â”€ utils/
    â”‚           â””â”€â”€ logger.ts
    â”œâ”€â”€ skills-plugin/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ example.ts
    â”‚   â”œâ”€â”€ hook-lifecycle-and-patterns.md
    â”‚   â”œâ”€â”€ implementation-pattern.md
    â”‚   â”œâ”€â”€ package.json
    â”‚   â””â”€â”€ tsconfig.json
    â””â”€â”€ .opencode/
        â”œâ”€â”€ opencode.json
        â””â”€â”€ agent/
            â””â”€â”€ codebase-agent.md

================================================
FILE: README.md
================================================
# OpenCode Plugin Starter & Demo

[![Tutorial Video](https://img.youtube.com/vi/Wu3G1QwM81M/0.jpg)](https://youtu.be/Wu3G1QwM81M)

This repository is a comprehensive starter kit and demonstration of OpenCode's extensibility. It includes a modular demo plugin and a structured library of context files for AI-assisted development.

## ðŸ“ Repository Structure

- `my-little-ui/`: A fully functional, modular OpenCode plugin.
  - Custom tools, agents, lifecycle hooks, and tool interception.
- `context/`: A library of Markdown files designed to provide LLMs with the knowledge needed to build OpenCode plugins.
- `.opencode/`: OpenCode configuration and custom agents for this repository.
  - `opencode.json`: Project-level configuration.
  - `agent/codebase-agent.md`: A specialized agent for building and maintaining this plugin, pre-configured with access to the `context/` library.
- `config.json`: Example OpenCode configuration for local plugin development.
- `package.json`: Root configuration referencing the local plugin.

## ðŸš€ Local Development

OpenCode makes local plugin development easy. This repo is set up so you can work on `my-little-ui` and see changes immediately.

1. **Build the plugin**:
   ```bash
   bun build my-little-ui/src/index.ts --outdir my-little-ui/dist --target bun --format esm
   ```
   Or using the root script:
   ```bash
   bun run build:plugin
   ```
   This bundles everything into a single file (e.g., `my-little-ui/dist/index.js`) that OpenCode can execute.
2. **Configure OpenCode**:
   The root `config.json` tells OpenCode to load the `my-little-ui` plugin.
3. **Reference local plugin**:
   The root `package.json` uses a local file reference: `"my-little-ui": "file:./my-little-ui"`.

## ðŸ“š AI Context Library

The `context/` folder is organized as a library. You can provide these files to an AI coding assistant to help it build features for you:

- [Context Overview](./context/context-overview.md) - **Start here!**
- **Architecture**: [Overview](./context/architecture/overview.md), [Lifecycle](./context/architecture/lifecycle.md)
- **Capabilities**: [Events](./context/capabilities/events.md), [Tools](./context/capabilities/tools.md), [Agents](./context/capabilities/agents.md)
- **Reference**: [Best Practices](./context/reference/best-practices.md)

## ðŸ› ï¸ Key Plugin Features

- **Interception Hooks**: Log or block tool executions before/after they happen.
- **Custom Agents**: Register specialized AI personalities with scoped toolsets.
- **Autonomous Tools**: Add logic (shell scripts, API calls) that agents can call.
- **Session Logging**: Isolated logging for every conversation.

Happy building! ðŸš€



================================================
FILE: config.json
================================================
{
    "$schema": "https://opencode.ai/config.json",
    "plugin": [
     "my-little-ui"
    ],
    "agent": {
      "explore": {
        "disable": true
      }
    }
}



================================================
FILE: package.json
================================================
{
  "name": "opencode-plugin-starter-root",
  "version": "1.0.0",
  "type": "module",
  "dependencies": {
    "@opencode-ai/plugin": "^1.0.187",
    "my-little-ui": "file:./my-little-ui",
    "@opencode/skills-plugin": "file:./skills-plugin"
  },
  "scripts": {
    "build:plugin": "cd my-little-ui && bun install && bun run build",
    "build:skills": "cd skills-plugin && bun install && bun run build",
    "dev:plugin": "cd my-little-ui && bun run dev",
    "dev:skills": "cd skills-plugin && bun run dev"
  }
}



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "lib": ["ESNext"],
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  }
}



================================================
FILE: context/context-overview.md
================================================
# OpenCode Plugin Context Library

This library provides structured context for AI coding assistants to understand, build, and extend OpenCode plugins. Depending on your task, you can load specific parts of this library.

## ðŸ“š Library Map

### ðŸ—ï¸ Architecture
Foundational concepts of how plugins are registered and executed.
- [Overview](./architecture/overview.md): Basic structure, registration, and context object.
- [Lifecycle](./architecture/lifecycle.md): Packaging, manifest, and session lifecycle.

### ðŸ› ï¸ Capabilities
Deep dives into specific plugin features.
- [Events](./capabilities/events.md): Detailed list of all 25+ hookable events.
- [Events: Skills Plugin](./capabilities/events_skills.md): Practical example of event hooks in the Skills Plugin.
- [Tools](./capabilities/tools.md): How to build and register custom tools using Zod.
- [Agents](./capabilities/agents.md): Creating and configuring custom AI agents.

### ðŸ“– Reference
Guidelines and troubleshooting.
- [Best Practices](./reference/best-practices.md): Message injection workarounds, security, and performance.

## ðŸš€ How to use this library
If you are asking an AI to build a new feature:
1. **For a new tool**: Provide `architecture/overview.md` and `capabilities/tools.md`.
2. **For reacting to events**: Provide `capabilities/events.md`.
3. **For overall plugin architecture**: Provide `architecture/overview.md` and `architecture/lifecycle.md`.



================================================
FILE: context/architecture/lifecycle.md
================================================
# Plugin Lifecycle & Packaging

## File Structure for Complex Plugins

For larger plugins, follow this recommended structure:

```
my-plugin/
â”œâ”€â”€ .claude-plugin/
â”‚   â””â”€â”€ plugin.json          # Manifest (required for packaging)
â”œâ”€â”€ commands/                # Custom slash commands
â”œâ”€â”€ agents/                  # Custom agents
â”œâ”€â”€ hooks/                   # Event handlers
â””â”€â”€ README.md               # Documentation
```

## The Manifest (`plugin.json`)

```json
{
  "name": "my-plugin",
  "description": "A custom plugin",
  "version": "1.0.0",
  "author": {
    "name": "Your Name"
  }
}
```

The `name` becomes the namespace prefix for commands: `/my-plugin:command`.

## SDK Access

Plugins have full access to the OpenCode SDK via `context.client`. This allows:
- Sending prompts programmatically: `client.session.prompt()`
- Managing sessions: `client.session.list()`, `client.session.get()`
- Showing UI elements: `client.tui.showToast()`
- Appending to prompt: `client.tui.appendPrompt()`



================================================
FILE: context/architecture/overview.md
================================================
# OpenCode Plugins Overview

OpenCode plugins are JavaScript or TypeScript modules that hook into **25+ events** across the entire OpenCode lifecycleâ€”from when you type a prompt, to when tools execute, to when sessions complete.

## Key Concepts

- **Zero-Config**: No build step or compilation required. Just drop `.ts` or `.js` files into the plugin folder.
- **Middleware Pattern**: Plugins subscribe to events and execute logic, similar to Express.js middleware.
- **Access**: Plugins receive a `context` object with:
  - `project`: Current project metadata.
  - `client`: OpenCode SDK client for programmatic control.
  - `$`: Bun's shell API for running commands.
  - `directory`: Current working directory.
  - `worktree`: Git worktree path.

## Plugin Registration

OpenCode looks for plugins in:
1. **Project-level**: `.opencode/plugin/` (project root)
2. **Global**: `~/.config/opencode/plugin/` (home directory)

## Basic Structure

```typescript
export const MyPlugin = async (context) => {
  const { project, client, $, directory, worktree } = context;

  return {
    event: async ({ event }) => {
      // Handle events here
    }
  };
};
```

Each exported function becomes a separate plugin instance. The name of the export is used as the plugin name.

## Build and Development

OpenCode plugins are typically written in TypeScript and bundled into a single JavaScript file for execution.

### Build Command
Use Bun to bundle the plugin into the `dist` directory:

```bash
bun build src/index.ts --outdir dist --target bun --format esm
```

The output will be a single file (e.g., `./index.js`) containing all dependencies.

### Development Workflow
1. **Source Code**: Write your plugin in `src/index.ts`.
2. **Bundle**: Run the build command to generate `dist/index.js`.
3. **Load**: Point OpenCode to the bundled file or the directory containing the manifest.
4. **Watch Mode**: For rapid development, use the `--watch` flag with Bun build:
   ```bash
   bun build src/index.ts --outdir dist --target bun --format esm --watch
   ```



================================================
FILE: context/capabilities/agents.md
================================================
# Custom Agents in OpenCode

Plugins can register custom AI agents that have specific roles, instructions, and toolsets.

## Agent Definition

Custom agents are configured in the plugin's `config` function.

```typescript
export const registerCustomAgents = (config) => {
  return {
    ...config,
    agents: [
      {
        name: "my-helper",
        description: "A friendly assistant for this project",
        instructions: "You are a helpful assistant. Use your tools to help the user.",
        model: "claude-3-5-sonnet-latest", // Specify the model
        tools: ["say_hello", "read", "write"] // Reference built-in or custom tools
      }
    ]
  };
};
```

## Integrating into Plugin

The `config` method in the plugin return object is used to register agents.

```typescript
export const MyPlugin: Plugin = async (context) => {
  return {
    config: async (currentConfig) => {
      return registerCustomAgents(currentConfig);
    },
    // ... other properties
  };
};
```

## Agent Capabilities
- **Model Choice**: You can select specific models for different agents.
- **Scoped Tools**: Limit what tools an agent can use to ensure safety or focus.
- **System Instructions**: Define the "personality" and rules for the agent.



================================================
FILE: context/capabilities/events.md
================================================
# OpenCode Plugin Events

OpenCode fires over 25 events that you can hook into. These are categorized below:

## Command Events
- `command.executed`: Fired when a user or plugin runs a command.

## File Events
- `file.edited`: Fired when a file is modified via OpenCode tools.
- `file.watcher.updated`: Fired when the file watcher detects changes.

## Message Events (Read-Only)
- `message.updated`: Fired when a message in the session updates.
- `message.part.updated`: Fired when individual parts of a message update.
- `message.part.removed`: Fired when a part is removed.
- `message.removed`: Fired when entire message is removed.

## Session Events
- `session.created`: New session started.
- `session.updated`: Session state changed.
- `session.idle`: Session completed (no more activity expected).
- `session.status`: Session status changed.
- `session.error`: Error occurred in session.
- `session.compacted`: Session was compacted (context summarized).

## Tool Events (Interception)
- `tool.execute.before`: Fired before a tool runs. **Can block execution** by throwing an error.
- `tool.execute.after`: Fired after a tool completes with result.

## TUI Events
- `tui.prompt.append`: Text appended to prompt input.
- `tui.command.execute`: Command executed from TUI.
- `tui.toast.show`: Toast notification shown.

## Mapping from Claude Code Hooks

| Claude Hook | OpenCode Event |
|---|---|
| PreToolUse | tool.execute.before |
| PostToolUse | tool.execute.after |
| UserPromptSubmit | message.* events |
| SessionEnd | session.idle |



================================================
FILE: context/capabilities/events_skills.md
================================================
# OpenCode Events: Skills Plugin Implementation

## Overview

This document explains how the OpenCode Skills Plugin uses event hooks (`tool.execute.before` and `tool.execute.after`) to implement skill delivery and output enhancement. This is a practical example of the event system described in `events.md`.

---

## Event Hooks Used

### tool.execute.before

**Event Type:** Tool Execution Interception

**When it fires:** Before a tool function executes

**Purpose in Skills Plugin:** Inject skill content into the conversation

**Implementation:**
```typescript
const beforeHook = async (input: any, output: any) => {
  // Check if this is a skill tool
  if (input.tool.startsWith("skills_")) {
    // Look up skill from map
    const skill = skillMap.get(input.tool)
    if (skill) {
      // Inject skill content as silent prompt
      await ctx.client.session.prompt({
        path: { id: input.sessionID },
        body: {
          agent: input.agent,
          noReply: true,  // Don't trigger AI response
          parts: [
            {
              type: "text",
              text: `ðŸ“š Skill: ${skill.name}\nBase directory: ${skill.fullPath}\n\n${skill.content}`,
            },
          ],
        },
      })
    }
  }
}
```

**Why use this hook?**
- Runs before tool execution, perfect for context injection
- Can access tool name and session ID
- Can inject content without triggering AI response
- Skill content persists in conversation history

**Input Parameters:**
- `input.tool` - Tool name (e.g., "skills_brand_guidelines")
- `input.sessionID` - Current session ID
- `input.agent` - Agent name that called the tool
- `output.args` - Tool arguments

**What you can do:**
- âœ… Inject context (skill content)
- âœ… Validate inputs
- âœ… Preprocess arguments
- âœ… Log tool calls
- âœ… Implement security checks

**What you can't do:**
- âŒ Modify tool output (tool hasn't run yet)
- âŒ Access tool results

---

### tool.execute.after

**Event Type:** Tool Execution Interception

**When it fires:** After a tool function completes

**Purpose in Skills Plugin:** Enhance output with visual feedback

**Implementation:**
```typescript
const afterHook = async (input: any, output: any) => {
  // Check if this is a skill tool
  if (input.tool.startsWith("skills_")) {
    // Look up skill from map
    const skill = skillMap.get(input.tool)
    if (skill && output.output) {
      // Add emoji title for visual feedback
      output.title = `ðŸ“š ${skill.name}`
    }
  }
}
```

**Why use this hook?**
- Runs after tool execution, perfect for output enhancement
- Can modify output properties
- Can add visual feedback (emoji titles)
- Can implement logging/analytics

**Input Parameters:**
- `input.tool` - Tool name (e.g., "skills_brand_guidelines")
- `input.sessionID` - Current session ID
- `output.output` - Tool result/output
- `output.title` - Output title (can be modified)

**What you can do:**
- âœ… Modify output
- âœ… Add titles/formatting
- âœ… Log completion
- âœ… Add analytics
- âœ… Transform results

**What you can't do:**
- âŒ Modify tool arguments (already executed)
- âŒ Prevent tool execution (already happened)

---

## Event Lifecycle in Skills Plugin

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    AGENT CALLS SKILL TOOL                       â”‚
â”‚                  (e.g., skills_brand_guidelines)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              EVENT: tool.execute.before fires                   â”‚
â”‚                                                                 â”‚
â”‚  Hook Function: beforeHook(input, output)                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ 1. Check: input.tool.startsWith("skills_")             â”‚   â”‚
â”‚  â”‚ 2. Lookup: skillMap.get(input.tool)                    â”‚   â”‚
â”‚  â”‚ 3. Inject: ctx.client.session.prompt({                 â”‚   â”‚
â”‚  â”‚      path: { id: input.sessionID },                    â”‚   â”‚
â”‚  â”‚      body: {                                            â”‚   â”‚
â”‚  â”‚        agent: input.agent,                             â”‚   â”‚
â”‚  â”‚        noReply: true,                                  â”‚   â”‚
â”‚  â”‚        parts: [{ type: "text", text: skill.content }]  â”‚   â”‚
â”‚  â”‚      }                                                  â”‚   â”‚
â”‚  â”‚    })                                                   â”‚   â”‚
â”‚  â”‚ 4. Result: Skill content added to conversation         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚
â”‚  Effect: Skill content persists in conversation history        â”‚
â”‚  No AI response triggered (noReply: true)                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TOOL.EXECUTE() RUNS                          â”‚
â”‚                                                                 â”‚
â”‚  async execute(args, toolCtx) {                                â”‚
â”‚    return `Skill activated: ${skill.name}`                     â”‚
â”‚  }                                                              â”‚
â”‚                                                                 â”‚
â”‚  Effect: Minimal confirmation returned                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              EVENT: tool.execute.after fires                    â”‚
â”‚                                                                 â”‚
â”‚  Hook Function: afterHook(input, output)                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ 1. Check: input.tool.startsWith("skills_")             â”‚   â”‚
â”‚  â”‚ 2. Lookup: skillMap.get(input.tool)                    â”‚   â”‚
â”‚  â”‚ 3. Verify: output.output exists                        â”‚   â”‚
â”‚  â”‚ 4. Enhance: output.title = `ðŸ“š ${skill.name}`          â”‚   â”‚
â”‚  â”‚ 5. Result: Output title modified with emoji            â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚
â”‚  Effect: Visual feedback added to output                       â”‚
â”‚  Could add logging/analytics here                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  RESULT RETURNED TO AGENT                       â”‚
â”‚                                                                 â”‚
â”‚  - Tool confirmation message                                    â”‚
â”‚  - Skill content in conversation history                        â”‚
â”‚  - Enhanced output with emoji title                             â”‚
â”‚  - Agent can now use skill content in reasoning                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Why Hooks Instead of Embedded Logic?

### Problem: Embedded Delivery (Anti-Pattern)

```typescript
// âŒ OLD: Skill delivery inside tool.execute()
async execute(args, toolCtx) {
  const sendSilentPrompt = (text: string) =>
    ctx.client.session.prompt({...})

  await sendSilentPrompt(`The "${skill.name}" skill is loading...`)
  await sendSilentPrompt(`Base directory: ${skill.fullPath}\n\n${skill.content}`)

  return `Launching skill: ${skill.name}`
}
```

**Issues:**
1. **Tight Coupling**: Tool logic and delivery are inseparable
2. **Hard to Test**: Can't test tool without testing delivery
3. **Violates SOLID**: Single Responsibility Principle broken
4. **No Reusability**: Delivery logic can't be extracted
5. **Difficult to Monitor**: Can't track delivery separately

---

### Solution: Hook-Based Delivery (Best Practice)

```typescript
// âœ… NEW: Separated concerns using hooks

// Tool: Minimal and focused
async execute(args, toolCtx) {
  return `Skill activated: ${skill.name}`
}

// Hook: Handles delivery
const beforeHook = async (input, output) => {
  if (input.tool.startsWith("skills_")) {
    const skill = skillMap.get(input.tool)
    if (skill) {
      await ctx.client.session.prompt({...})
    }
  }
}
```

**Benefits:**
1. âœ… **Loose Coupling**: Tool and delivery are independent
2. âœ… **Easy to Test**: Each component tested separately
3. âœ… **SOLID Compliant**: Single Responsibility Principle
4. âœ… **Reusable**: Hooks can be composed with other plugins
5. âœ… **Monitorable**: Can add logging/analytics independently

---

## Skill Lookup Map: Performance Optimization

### Why a Map?

The skill lookup map enables O(1) access instead of O(n) search:

```typescript
// âœ… EFFICIENT: O(1) lookup
const skillMap = new Map<string, Skill>()
for (const skill of skills) {
  skillMap.set(skill.toolName, skill)
}

const beforeHook = async (input, output) => {
  if (input.tool.startsWith("skills_")) {
    const skill = skillMap.get(input.tool)  // O(1) constant time
    if (skill) {
      // Use skill
    }
  }
}
```

### Performance Impact

| Number of Skills | Array Search (O(n)) | Map Lookup (O(1)) | Speedup |
|------------------|-------------------|------------------|---------|
| 10 | 10 comparisons | 1 lookup | 10x |
| 100 | 100 comparisons | 1 lookup | 100x |
| 1000 | 1000 comparisons | 1 lookup | 1000x |

**Conclusion:** Map lookup is essential for scalability

---

## Integration with OpenCode Event System

### Event Mapping

| OpenCode Event | Skills Plugin Hook | Purpose |
|---|---|---|
| `tool.execute.before` | `beforeHook` | Skill content injection |
| `tool.execute.after` | `afterHook` | Output enhancement |

### Plugin Return Object

```typescript
return {
  // Custom tools
  tool: tools,

  // Hook: Runs before tool execution
  "tool.execute.before": beforeHook,

  // Hook: Runs after tool execution
  "tool.execute.after": afterHook,
}
```

**Key Points:**
- Hooks apply to ALL tools (use `if` statements to filter)
- Multiple plugins can register hooks without conflict
- Hooks run in registration order
- Hooks can be async

---

## Comparison with Other Event Hooks

### Available Tool Execution Hooks

| Hook | When | Use Case |
|------|------|----------|
| `tool.execute.before` | Before tool runs | Input validation, context injection, preprocessing |
| `tool.execute.after` | After tool completes | Output formatting, logging, analytics |

### Other Event Hooks (Not Used in Skills Plugin)

| Hook | When | Use Case |
|------|------|----------|
| `session.created` | Session starts | Welcome messages, initialization |
| `message.updated` | Message changes | Monitoring, logging |
| `session.idle` | Session completes | Cleanup, background tasks |
| `session.error` | Error occurs | Error handling, logging |

---

## Real-World Example: Skill Delivery Flow

### Step 1: Agent Calls Skill Tool

```
Agent: "Use the brand-guidelines skill"
â†“
OpenCode: Calls skills_brand_guidelines tool
```

### Step 2: Before Hook Fires

```typescript
const beforeHook = async (input, output) => {
  // input.tool = "skills_brand_guidelines"
  // input.sessionID = "ses_abc123"
  // input.agent = "my-helper"

  if (input.tool.startsWith("skills_")) {
    const skill = skillMap.get("skills_brand_guidelines")
    // skill = {
    //   name: "brand-guidelines",
    //   description: "Brand guidelines for the project",
    //   content: "# Brand Guidelines\n\n...",
    //   fullPath: "/path/to/skill"
    // }

    await ctx.client.session.prompt({
      path: { id: "ses_abc123" },
      body: {
        agent: "my-helper",
        noReply: true,
        parts: [
          {
            type: "text",
            text: "ðŸ“š Skill: brand-guidelines\nBase directory: /path/to/skill\n\n# Brand Guidelines\n\n..."
          }
        ]
      }
    })
  }
}
```

**Result:** Skill content added to conversation, no AI response

### Step 3: Tool Executes

```typescript
async execute(args, toolCtx) {
  // Minimal logic
  return `Skill activated: brand-guidelines`
}
```

**Result:** Simple confirmation returned

### Step 4: After Hook Fires

```typescript
const afterHook = async (input, output) => {
  // input.tool = "skills_brand_guidelines"
  // output.output = "Skill activated: brand-guidelines"

  if (input.tool.startsWith("skills_")) {
    const skill = skillMap.get("skills_brand_guidelines")
    if (skill && output.output) {
      output.title = `ðŸ“š brand-guidelines`
    }
  }
}
```

**Result:** Output title enhanced with emoji

### Step 5: Agent Receives Result

```
Conversation History:
â”œâ”€ User: "Use the brand-guidelines skill"
â”œâ”€ Tool Call: skills_brand_guidelines
â”œâ”€ Silent Message: "ðŸ“š Skill: brand-guidelines\n..."
â”œâ”€ Tool Result: "Skill activated: brand-guidelines"
â”‚  (with title: "ðŸ“š brand-guidelines")
â””â”€ Agent: "I now have the brand guidelines. I can help with..."
```

---

## Testing Hooks

### Testing Before Hook

```typescript
describe("beforeHook", () => {
  it("should inject skill content for skill tools", async () => {
    const input = {
      tool: "skills_brand_guidelines",
      sessionID: "ses_test",
      agent: "test-agent"
    }
    const output = { args: {} }

    const mockPrompt = jest.fn()
    ctx.client.session.prompt = mockPrompt

    await beforeHook(input, output)

    expect(mockPrompt).toHaveBeenCalledWith(
      expect.objectContaining({
        path: { id: "ses_test" },
        body: expect.objectContaining({
          agent: "test-agent",
          noReply: true,
          parts: expect.arrayContaining([
            expect.objectContaining({
              type: "text",
              text: expect.stringContaining("brand-guidelines")
            })
          ])
        })
      })
    )
  })

  it("should skip non-skill tools", async () => {
    const input = { tool: "read_file", sessionID: "ses_test" }
    const output = { args: {} }

    const mockPrompt = jest.fn()
    ctx.client.session.prompt = mockPrompt

    await beforeHook(input, output)

    expect(mockPrompt).not.toHaveBeenCalled()
  })
})
```

### Testing After Hook

```typescript
describe("afterHook", () => {
  it("should add emoji title for skill tools", async () => {
    const input = { tool: "skills_brand_guidelines" }
    const output = { output: "Skill activated" }

    await afterHook(input, output)

    expect(output.title).toBe("ðŸ“š brand-guidelines")
  })

  it("should skip non-skill tools", async () => {
    const input = { tool: "read_file" }
    const output = { output: "File content" }

    await afterHook(input, output)

    expect(output.title).toBeUndefined()
  })

  it("should skip if output is missing", async () => {
    const input = { tool: "skills_brand_guidelines" }
    const output = { output: null }

    await afterHook(input, output)

    expect(output.title).toBeUndefined()
  })
})
```

---

## Common Patterns

### Pattern 1: Tool-Specific Hooks

```typescript
const beforeHook = async (input, output) => {
  switch (input.tool) {
    case "skills_brand_guidelines":
      // Handle brand guidelines
      break
    case "skills_api_reference":
      // Handle API reference
      break
    default:
      // Skip non-skill tools
  }
}
```

### Pattern 2: Conditional Processing

```typescript
const beforeHook = async (input, output) => {
  if (input.tool.startsWith("skills_")) {
    const skill = skillMap.get(input.tool)
    if (skill && skill.allowedTools?.includes(input.agent)) {
      // Process only if allowed
    }
  }
}
```

### Pattern 3: Logging & Monitoring

```typescript
const beforeHook = async (input, output) => {
  if (input.tool.startsWith("skills_")) {
    console.log(`[BEFORE] Skill tool called: ${input.tool}`)
    console.log(`[BEFORE] Session: ${input.sessionID}`)
  }
}

const afterHook = async (input, output) => {
  if (input.tool.startsWith("skills_")) {
    console.log(`[AFTER] Skill tool completed: ${input.tool}`)
    console.log(`[AFTER] Output length: ${output.output?.length || 0}`)
  }
}
```

### Pattern 4: Error Handling

```typescript
const beforeHook = async (input, output) => {
  try {
    if (input.tool.startsWith("skills_")) {
      const skill = skillMap.get(input.tool)
      if (!skill) {
        throw new Error(`Skill not found: ${input.tool}`)
      }
      // Process skill
    }
  } catch (error) {
    console.error(`Hook error:`, error)
    // Don't rethrow - let tool execute anyway
  }
}
```

---

## Key Takeaways

1. **Hooks are middleware**: They intercept tool execution at specific points
2. **Before hook**: For preprocessing, validation, context injection
3. **After hook**: For output enhancement, logging, analytics
4. **Lookup maps**: Enable O(1) access instead of O(n) search
5. **Separation of concerns**: Tools do one thing, hooks do another
6. **Composability**: Multiple plugins can register hooks without conflict
7. **Testability**: Each component can be tested independently
8. **Maintainability**: Changes are isolated to specific hooks

---

## References

- **OpenCode Events**: `context/capabilities/events.md`
- **Tool Definition**: `context/capabilities/tools.md`
- **Best Practices**: `context/reference/best-practices.md`
- **Skills Plugin Example**: `skills-plugin/example.ts`
- **Hook Lifecycle**: `skills-plugin/hook-lifecycle-and-patterns.md`
- **Implementation Pattern**: `skills-plugin/implementation-pattern.md`




================================================
FILE: context/capabilities/tools.md
================================================
# Building Custom Tools

Plugins can add custom tools that OpenCode agents can call autonomously.

## Tool Definition

Custom tools use Zod for schema definition and the `tool` helper from `@opencode-ai/plugin`.

```typescript
import { z } from 'zod';
import { tool } from '@opencode-ai/plugin';

export const MyCustomTool = tool(
  z.object({
    query: z.string().describe('Search query'),
    limit: z.number().default(10).describe('Results limit')
  }),
  async (args, context) => {
    const { query, limit } = args;
    // Implementation logic
    return { success: true, data: [] };
  }
).describe('Search your database');
```

## Shell-based Tools

You can leverage Bun's shell API (`$`) to run commands in any language.

```typescript
export const PythonCalculatorTool = tool(
  z.object({ expression: z.string() }),
  async (args, context) => {
    const { $ } = context;
    const result = await $`python3 -c 'print(eval("${args.expression}"))'`;
    return { result: result.stdout };
  }
).describe('Calculate mathematical expressions');
```

## Integration

To register tools in your plugin:

```typescript
export const MyPlugin = async (context) => {
  return {
    tool: [MyCustomTool, PythonCalculatorTool]
  };
};
```



================================================
FILE: context/reference/best-practices.md
================================================
# Best Practices & Limitations

## Message Injection Workarounds

**The Reality**: The message system is largely read-only. You cannot mutate messages mid-stream or inject text directly into an existing message part.

### What Doesn't Work
- Modifying `event.data.content` in `message.updated`.
- Retroactively changing AI responses.

### What Works
1. **Initial Context**: Use `session.created` to inject a starting message using `client.session.prompt()`.
2. **Prompt Decoration**: Use `client.tui.appendPrompt()` to add text to the user's input box before they hit enter.
3. **Tool Interception**: Use `tool.execute.before` to modify arguments *before* the tool runs.
4. **On-Demand Context**: Provide custom tools that the AI can call when it needs more information.

## Security

- Always validate tool inputs in `tool.execute.before`.
- Use environment variables for sensitive data; do not hardcode API keys.
- Be careful with the `$` shell API to prevent command injection.

## Performance

- Avoid heavy synchronous operations in event handlers as they can block the TUI.
- Use the `session.idle` event for cleanup or background sync tasks.



================================================
FILE: my-little-ui/package.json
================================================
{
  "name": "my-little-ui",
  "version": "1.0.0",
  "description": "A demonstration OpenCode plugin showcasing core plugin capabilities",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "type": "module",
  "files": [
    "dist"
  ],
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    }
  },
  "scripts": {
    "build": "bun build src/index.ts --outdir dist --target bun --format esm && tsc --emitDeclarationOnly",
    "dev": "bun build src/index.ts --outdir dist --target bun --format esm --watch",
    "type-check": "tsc --noEmit"
  },
  "keywords": [
    "opencode",
    "plugin",
    "ai"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@opencode-ai/plugin": "^1.0.162",
    "chalk": "^5.3.0"
  },
  "devDependencies": {
    "bun-types": "latest",
    "typescript": "^5.7.3"
  },
  "peerDependencies": {
    "bun": ">=1.0.0"
  }
}



================================================
FILE: my-little-ui/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "declaration": true,
    "declarationDir": "dist",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "lib": ["ESNext"],
    "types": ["bun-types"],
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}



================================================
FILE: my-little-ui/src/index.ts
================================================
import type { Plugin } from "@opencode-ai/plugin";
import { Logger } from "./utils/logger";
import { registerPluginTools } from "./tools";
import { registerCustomAgents } from "./agents";
import { setupLifecycleHandlers } from "./lifecycle";
import { setupToolExecutionHooks } from "./hooks";
import { getPluginName, getPluginVersion, getPluginDescription } from "./plugin-info";

/**
 * My Little Plugin
 * 
 * Version: 1.0.0
 * Description: A demonstration OpenCode plugin showcasing core plugin capabilities
 * 
 * ============================================================================
 * PLUGIN ARCHITECTURE
 * ============================================================================
 * 
 * This plugin is organized into clear, modular components:
 * 
 * 1. ðŸ“¦ UTILS (src/utils/)
 *    - logger.ts: Session-scoped logging utility
 *    Purpose: Provides logging for debugging and monitoring
 * 
 * 2. ðŸ› ï¸  TOOLS (src/tools/)
 *    - say-hello.ts: Greeting tool with enthusiasm option
 *    - quick-shell.ts: Shell command execution
 *    - view-logs.ts: Log viewing and management
 *    - plugin-info.ts: Self-documentation tool
 *    Purpose: Custom tools that agents can use
 *    Function: registerPluginTools()
 * 
 * 3. ðŸ¤– AGENTS (src/agents/)
 *    - my-helper-agent.ts: Custom agent definition
 *    Purpose: Registers custom AI agents into OpenCode
 *    Function: registerCustomAgents()
 * 
 * 4. ðŸ”„ LIFECYCLE (src/lifecycle/)
 *    - on-session-created.ts: Session creation handler
 *    Purpose: Handles OpenCode lifecycle events
 *    Function: setupLifecycleHandlers()
 * 
 * 5. ðŸª HOOKS (src/hooks/)
 *    - tool-hooks.ts: Before/after execution hooks
 *    Purpose: Intercepts tool execution for logging and enhancement
 *    Function: setupToolExecutionHooks()
 * 
 * 6. â„¹ï¸  PLUGIN INFO (src/plugin-info.ts)
 *    - Version management
 *    - Status checks
 *    - Feature documentation
 *    Purpose: Centralized plugin metadata and status
 *    Functions: getPluginVersion(), getPluginStatus(), etc.
 * 
 * ============================================================================
 * PLUGIN FEATURES
 * ============================================================================
 * 
 * âœ… Session-scoped logging (.tmp/my-little-plugin/)
 * âœ… Custom tool registration (4 tools)
 * âœ… Custom agent registration (my-helper)
 * âœ… Lifecycle event handling (toast notifications)
 * âœ… Tool execution hooks (logging & output modification)
 * âœ… Version tracking and status reporting
 * 
 * ============================================================================
 * BENEFITS OF THIS ARCHITECTURE
 * ============================================================================
 * 
 * ðŸ“ Clear separation of concerns - Each module has one job
 * ðŸ” Easy to understand - File names match their purpose
 * ðŸ§ª Testable - Each module can be tested independently
 * ðŸ“ˆ Scalable - Easy to add new features without complexity
 * ðŸ› ï¸  Maintainable - Changes are isolated to specific modules
 * ðŸ“š Self-documenting - Function names describe what they do
 * 
 * ============================================================================
 */

const MyLittlePlugin: Plugin = async ({ client, directory, $ }) => {
  // ============================================================================
  // LOGGER SETUP
  // ============================================================================
  // Initialize session-scoped logger management
  // Each session gets its own logger instance for isolated logging
  
  const loggers = new Map<string, Logger>();
  
  const getLogger = (sessionID: string): Logger => {
    if (!loggers.has(sessionID)) {
      loggers.set(sessionID, new Logger(directory, sessionID));
    }
    return loggers.get(sessionID)!;
  };

  // ============================================================================
  // COMPONENT INITIALIZATION
  // ============================================================================
  // Create all plugin components using factory functions
  // Each function returns configured handlers for OpenCode
  
  const tools = registerPluginTools({ getLogger, directory, $ });
  const hooks = setupToolExecutionHooks(getLogger);
  const lifecycleHandler = setupLifecycleHandlers(directory, client);

  // ============================================================================
  // PLUGIN DEFINITION
  // ============================================================================
  // Return the plugin object that OpenCode will use
  // This defines all the plugin's capabilities and hooks
  
  return {
    /**
     * FEATURE 1: Custom Tools
     * 
     * Function: registerPluginTools()
     * Location: src/tools/index.ts
     * 
     * Registers 4 custom tools that agents can use:
     * - say_hello: Greet users
     * - quick_shell: Execute shell commands
     * - view_logs: View session logs
     * - plugin_info: Show plugin information
     */
    tool: tools,

    /**
     * FEATURE 2: Custom Agents
     * 
     * Function: registerCustomAgents()
     * Location: src/agents/index.ts
     * 
     * Registers custom AI agents:
     * - my-helper: Friendly demo agent (Claude Sonnet 4)
     */
    config: async (config) => {
      return registerCustomAgents(config);
    },

    /**
     * FEATURE 3: Lifecycle Events
     * 
     * Function: setupLifecycleHandlers()
     * Location: src/lifecycle/index.ts
     * 
     * Handles OpenCode lifecycle events:
     * - session.created: Shows welcome toast with version
     */
    event: lifecycleHandler,

    /**
     * FEATURE 4: Tool Execution Hooks
     * 
     * Function: setupToolExecutionHooks()
     * Location: src/hooks/index.ts
     * 
     * Intercepts tool execution:
     * - tool.execute.before: Logs tool calls
     * - tool.execute.after: Logs completion, adds emoji titles
     */
    "tool.execute.before": hooks.before,
    "tool.execute.after": hooks.after,
  };
};

// ============================================================================
// EXPORT
// ============================================================================
// Export the plugin for OpenCode to load

export default MyLittlePlugin;



================================================
FILE: my-little-ui/src/plugin-info.ts
================================================
/**
 * Plugin Information Module
 * 
 * Purpose: Provides metadata and status information about the plugin
 * 
 * This module contains functions that help users understand:
 * - What version of the plugin they're using
 * - Whether the plugin is working correctly
 * - What features are available
 * - How to use the plugin
 * 
 * These functions are used by:
 * - The plugin_info tool
 * - Toast notifications
 * - Status checks
 * - Documentation
 */

/**
 * Function: getPluginVersion()
 * Returns: The current version of the plugin
 */
export const getPluginVersion = (): string => {
  return "1.0.0";
};

/**
 * Function: getPluginName()
 * Returns: The display name of the plugin
 */
export const getPluginName = (): string => {
  return "My UI Plugin";
};

/**
 * Function: getPluginDescription()
 * Returns: A brief description of what the plugin does
 */
export const getPluginDescription = (): string => {
  return "A demonstration OpenCode plugin showcasing core plugin capabilities";
};

/**
 * Function: isPluginActive()
 * Returns: Always true (if this code runs, plugin is active!)
 * 
 * This function confirms the plugin is loaded and working.
 * If you can call this function, the plugin is active.
 */
export const isPluginActive = (): boolean => {
  return true;
};

/**
 * Function: getPluginFeatures()
 * Returns: List of all features the plugin provides
 * 
 * This helps users understand what the plugin can do.
 */
export const getPluginFeatures = (): string[] => {
  return [
    "âœ… Session-scoped logging (.tmp/my-little-plugin/)",
    "âœ… Custom tool registration (4 tools)",
    "âœ… Config modification (custom agents)",
    "âœ… Event handling (toast notifications)",
    "âœ… Tool execution hooks (output modification)",
  ];
};

/**
 * Function: getPluginTools()
 * Returns: List of all tools provided by the plugin
 */
export const getPluginTools = (): Array<{ name: string; description: string }> => {
  return [
    {
      name: "say_hello",
      description: "Greets someone with optional enthusiasm",
    },
    {
      name: "quick_shell",
      description: "Executes shell commands via Bun's shell API",
    },
    {
      name: "view_logs",
      description: "View the plugin's session logs and recent entries",
    },
    {
      name: "plugin_info",
      description: "Shows information about the plugin",
    },
  ];
};

/**
 * Function: getPluginAgents()
 * Returns: List of custom agents provided by the plugin
 */
export const getPluginAgents = (): Array<{ name: string; description: string }> => {
  return [
    {
      name: "my-helper",
      description: "A friendly demo agent (Claude Sonnet 4)",
    },
  ];
};

/**
 * Function: getPluginStatus()
 * Returns: Overall status information about the plugin
 * 
 * This provides a comprehensive status check showing:
 * - Version
 * - Active status
 * - Feature count
 * - Tool count
 * - Agent count
 */
export const getPluginStatus = () => {
  return {
    name: getPluginName(),
    version: getPluginVersion(),
    description: getPluginDescription(),
    active: isPluginActive(),
    features: getPluginFeatures(),
    tools: getPluginTools(),
    agents: getPluginAgents(),
    emoji: "ðŸš€",
    message: "Plugin is active and working! Enjoy using My Little Plugin! ðŸŽ‰",
  };
};

/**
 * Function: getWelcomeMessage()
 * Returns: A friendly welcome message for users
 * 
 * This is shown in the toast notification when a session starts.
 */
export const getWelcomeMessage = (logDir: string): string => {
  return `ðŸŽ‰ ${getPluginName()} v${getPluginVersion()} is active! Session logging enabled at: ${logDir}`;
};

/**
 * Function: getPluginTitle()
 * Returns: Formatted title for tool outputs
 */
export const getPluginTitle = (): string => {
  return `â„¹ï¸  ${getPluginName()} v${getPluginVersion()}`;
};



================================================
FILE: my-little-ui/src/agents/index.ts
================================================
import { myHelperAgentDefinition } from "./my-helper-agent";

/**
 * Agents Module
 * 
 * Purpose: Registers custom agents into OpenCode
 * 
 * This module handles the registration of custom AI agents.
 * Custom agents extend OpenCode's capabilities by:
 * - Using specific AI models
 * - Having specialized prompts
 * - Accessing plugin-specific tools
 * - Operating as subagents
 * 
 * Function: registerCustomAgents()
 * - Takes the current OpenCode config
 * - Injects custom agent definitions
 * - Returns modified config with new agents
 */

export const registerCustomAgents = async (config: any) => {
  // Register the my-helper agent
  if (!config.agent) config.agent = {};
  
  config.agent["my-helper"] = myHelperAgentDefinition;
  
  // Future: Add more custom agents here
  // config.agent["another-agent"] = anotherAgentDefinition;
  
  return config;
};



================================================
FILE: my-little-ui/src/agents/my-helper-agent.ts
================================================
/**
 * My Helper Agent Definition
 * 
 * Purpose: Defines the "my-helper" custom agent
 * 
 * This agent demonstrates how plugins can create custom AI agents with:
 * - Specific AI models (Claude Sonnet 4)
 * - Custom system prompts
 * - Access to plugin-specific tools
 * - Subagent mode for delegation
 * 
 * The agent is friendly, cheerful, and helps users understand
 * how custom agents work in OpenCode plugins.
 */

export const myHelperAgentDefinition = {
  description: "A friendly helper agent added by my-little-plugin",
  model: "anthropic/claude-sonnet-4",
  mode: "subagent" as const,
  prompt: `You are a friendly helper agent created by my-little-plugin.

Your purpose is to demonstrate how custom agents work in OpenCode plugins.

You have access to special tools:
- say_hello: Greet people enthusiastically
- quick_shell: Execute shell commands
- plugin_info: Show information about the plugin

When asked to help, be cheerful and mention that you're a demo agent from my-little-plugin!`,
  color: "#FF69B4",
};



================================================
FILE: my-little-ui/src/components/banner.ts
================================================
import chalk from "chalk";

export type BannerType = "success" | "error" | "warning" | "info";

export interface BannerOptions {
  subtitle?: string;
}

export interface ArtBanner {
  art: string[];
  icon: string;
  defaultColor: (text: string) => string;
}

export class Banner {
  constructor(
    private type: BannerType,
    private message: string,
    private options?: BannerOptions
  ) {}

  render(): string {
    const icons = {
      success: "âœ“",
      error: "âœ—",
      warning: "âš ",
      info: "â„¹",
    };

    const colors = {
      success: chalk.green,
      error: chalk.red,
      warning: chalk.yellow,
      info: chalk.blue,
    };

    const icon = icons[this.type];
    const color = colors[this.type];

    const border = "â”".repeat(50);
    const lines: string[] = [];

    lines.push(color(border));
    lines.push(color(`  ${icon} ${this.message}`));

    if (this.options?.subtitle) {
      lines.push(color(`  ${this.options.subtitle}`));
    }

    lines.push(color(border));

    return lines.join("\n");
  }
}

export class ArtisticBanner {
  constructor(
    private artBanner: ArtBanner,
    private message?: string,
    private subtitle?: string
  ) {}

  render(): string {
    const lines: string[] = [];
    
    // Add the ASCII art
    const artLines = this.artBanner.art.map(line =>
      this.artBanner.defaultColor(line)
    );
    lines.push(...artLines);

    // Add message if provided
    if (this.message) {
      lines.push("");
      lines.push(
        this.artBanner.defaultColor(
          `    ${this.artBanner.icon} ${this.message}`
        )
      );
    }

    // Add subtitle if provided
    if (this.subtitle) {
      lines.push(this.artBanner.defaultColor(`    ${this.subtitle}`));
    }

    return lines.join("\n");
  }
}

export function createBanner(
  type: BannerType,
  message: string,
  options?: BannerOptions
): string {
  return new Banner(type, message, options).render();
}

export function createArtisticBanner(
  artBanner: ArtBanner,
  message?: string,
  subtitle?: string
): string {
  return new ArtisticBanner(artBanner, message, subtitle).render();
}



================================================
FILE: my-little-ui/src/components/banners.ts
================================================
import chalk from "chalk";
import type { ArtBanner } from "./banner";


export const OPENAGENT_BANNER: ArtBanner = {
  art: [
    "  ðŸŽ‰  OpenAgents  ðŸŽ‰",
    " ",
    "  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—",
    " â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•",
    " â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—",
    " â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â•šâ•â•â•â•â–ˆâ–ˆâ•‘",
    " â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘",
    "  â•šâ•â•â•â•â• â•šâ•â•     â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•",
    " ",
    "  ðŸŽŠ  ðŸŽ‰  ðŸŽŠ",
  ],
  icon: "ðŸ¤–",
  defaultColor: chalk.cyan,
};

export const GO_BANNER: ArtBanner = {
  art: [
    "  ðŸš€  GO!  ðŸš€",
    " ",
    "   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— ",
    "  â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—",
    "  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘",
    "  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘",
    "  â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•",
    "   â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• ",
  ],
  icon: "ðŸš€",
  defaultColor: chalk.green,
};

export const ERROR_BANNER: ArtBanner = {
  art: [
    "  âŒ  ERROR  âŒ",
    " ",
    "  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— ",
    "  â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—",
    "  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•",
    "  â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—",
    "  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘",
    "  â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•",
  ],
  icon: "âŒ",
  defaultColor: chalk.red,
};



================================================
FILE: my-little-ui/src/hooks/index.ts
================================================
import type { Logger } from "../utils/logger";
import { interceptToolExecutionBefore, interceptToolExecutionAfter } from "./tool-hooks";

/**
 * Hooks Module
 * 
 * Purpose: Sets up OpenCode lifecycle hooks for tool execution
 * 
 * This module provides hooks that intercept tool execution:
 * - tool.execute.before: Runs before any tool executes
 * - tool.execute.after: Runs after any tool completes
 * 
 * Function: setupToolExecutionHooks()
 * - Creates before/after hook handlers
 * - Enables logging and monitoring
 * - Enhances tool outputs with emojis
 * - Returns hook handlers for OpenCode
 * 
 * Hooks allow plugins to:
 * - Monitor tool usage
 * - Log for debugging
 * - Modify tool outputs
 * - Add metadata to results
 */

export const setupToolExecutionHooks = (getLogger: (sessionID: string) => Logger) => {
  return {
    before: interceptToolExecutionBefore(getLogger),
    after: interceptToolExecutionAfter(getLogger),
  };
};



================================================
FILE: my-little-ui/src/hooks/tool-hooks.ts
================================================
import type { Logger } from "../utils/logger";
import { getPluginTitle } from "../plugin-info";

/**
 * Tool Execution Hooks
 * 
 * Purpose: Intercept and modify tool execution lifecycle
 * 
 * These hooks demonstrate how plugins can:
 * - Monitor tool usage
 * - Log tool calls for debugging
 * - Modify tool outputs
 * - Add metadata to tool results
 * - Implement cross-cutting concerns (logging, analytics, etc.)
 * 
 * Hook Types:
 * - tool.execute.before: Called before tool execution
 * - tool.execute.after: Called after tool execution
 * 
 * Use Cases:
 * - Logging and debugging
 * - Performance monitoring
 * - Output formatting
 * - Error tracking
 * - Usage analytics
 */

/**
 * Function: interceptToolExecutionBefore()
 * 
 * Purpose: Logs tool calls before they execute
 * Hook: tool.execute.before
 * 
 * This function runs before any tool executes and:
 * - Logs the tool name
 * - Logs the arguments passed to the tool
 * - Helps with debugging and monitoring
 */
export const interceptToolExecutionBefore = (getLogger: (sessionID: string) => Logger) => {
  return async (input: any, output: any) => {
    if (input.sessionID) {
      getLogger(input.sessionID).log(`ðŸ”§ Tool called: ${input.tool}`, { 
        args: output.args 
      });
    }
  };
};

/**
 * Function: interceptToolExecutionAfter()
 * 
 * Purpose: Logs tool completion and enhances output
 * Hook: tool.execute.after
 * 
 * This function runs after any tool executes and:
 * - Logs successful completion
 * - Adds emoji titles to tool outputs
 * - Enhances user experience with visual feedback
 */
export const interceptToolExecutionAfter = (getLogger: (sessionID: string) => Logger) => {
  return async (input: any, output: any) => {
    // Log completion
    if (input.sessionID) {
      getLogger(input.sessionID).log(`âœ… Tool completed: ${input.tool}`, { 
        hasOutput: !!output.output 
      });
    }
    
    // Modify output titles with contextual emojis
    if (output.output) {
      if (input.tool === "say_hello") {
        output.title = `ðŸ‘‹ ${output.output.slice(0, 50)}`;
      } else if (input.tool === "plugin_info") {
        output.title = getPluginTitle();
      } else if (input.tool === "view_logs") {
        output.title = "ðŸ“‹ Plugin Logs";
      }
    }
  };
};



================================================
FILE: my-little-ui/src/lifecycle/index.ts
================================================
import { handleSessionCreated } from "./on-session-created";
import { OpencodeClient } from "@opencode-ai/sdk";
import { createArtisticBanner } from "../components/banner";
import { GO_BANNER, ERROR_BANNER } from "../components/banners";

/**
 * Lifecycle Module
 * 
 * Purpose: Manages OpenCode lifecycle event handlers
 */

export const setupLifecycleHandlers = (directory: string, client: OpencodeClient) => {
  let firstMessageResponded = false;

  return async ({ event }: { event: any }) => {
    // Route lifecycle events to appropriate handlers
    if (event.type === "session.created") {
      await handleSessionCreated(directory, client);
    }

    // Handle first AI response
    if (event.type === "message.updated" && !firstMessageResponded) {
      const message = event.data;
      // Check if it's an AI message and has content
     
        firstMessageResponded = true;
        
        const goBanner = createArtisticBanner(GO_BANNER, "AI Responded!", "The agent is ready to help.");

        
        await client.tui.showToast({
          body: {
            title: "ðŸš€ GO! AI is active",
            message: goBanner,
            variant: "success",
          },
        }).catch(() => {});
      
    }

    // Handle session errors
    if (event.type === "session.error") {
      const errorBanner = createArtisticBanner(ERROR_BANNER, "Session Error", event.data?.message || "Unknown error");
      console.log(errorBanner);
      
      await client.tui.showToast({
        body: {
          title: "âŒ Session Error",
          message: event.data?.message || "Check logs for details",
          variant: "error",
        },
      }).catch(() => {});
    }
  };
};



================================================
FILE: my-little-ui/src/lifecycle/on-session-created.ts
================================================
import { getPluginName, getPluginVersion, getWelcomeMessage } from "../plugin-info";
import { OpencodeClient } from "@opencode-ai/sdk";
import { createArtisticBanner } from "../components/banner";
import { OPENAGENT_BANNER } from "../components/banners";

/**
 * On Session Created Handler
 */

export const handleSessionCreated = async (
  directory: string,
  client: OpencodeClient
) => {
  const logDir = `${directory}/.tmp/my-little-plugin`;
  
  // 1. Display the main OpenAgents banner on startup
  const welcomeBanner = createArtisticBanner(
    OPENAGENT_BANNER,
    `${getPluginName()} v${getPluginVersion()}`,
    `Logs: ${logDir}`
  );
 
  const sessions = await client.session.list();
  const currentSession = sessions.data?.[0]; // Most recent session

  if (currentSession) {
    // ðŸŽ¯ Inject banner as a system message BEFORE AI responds
    await client.session.prompt({
      path: { id: currentSession.id },
      body: {
        parts: [{ type: "text", text: createArtisticBanner(OPENAGENT_BANNER) }],
        noReply: true,  // â­ KEY: Don't wait for AI response
      },
    }).catch((e) => {
      console.error("Failed to inject banner:", e);
    });
  }

 
  
  // 2. Show a welcoming toast
  // await client.tui
  //   .showToast({
  //     body: {
  //       title: `ðŸ¤– ${getPluginName()} Active`,
  //       message: "Session initialized with OpenAgents UI",
  //       variant: "info",
  //     },
  //   })
  //   .catch(() => {});

  // 3. Append a hint to the prompt
  await client.tui.appendPrompt({
    body: {
      text: "OpenAgents UI plugin is active. How can I help?",
    },
  }).catch(() => {});
};


================================================
FILE: my-little-ui/src/tools/index.ts
================================================
import type { Logger } from "../utils/logger";
import { createSayHelloTool } from "./say-hello";
import { createQuickShellTool } from "./quick-shell";
import { createViewLogsTool } from "./view-logs";
import { createPluginInfoTool } from "./plugin-info";

/**
 * Tools Module
 * 
 * Purpose: Registers all custom tools for the plugin
 * 
 * This module provides tools that agents can use:
 * - say_hello: Greet users with optional enthusiasm
 * - quick_shell: Execute shell commands
 * - view_logs: View session logs
 * - plugin_info: Show plugin information
 * 
 * Function: registerPluginTools()
 * - Takes dependencies (logger, directory, shell)
 * - Creates all tool instances
 * - Returns tool registry for OpenCode
 * 
 * Benefits:
 * - Clear separation of concerns
 * - Easy to test individual tools
 * - Simple to add new tools
 * - Dependencies are explicit
 */

export interface ToolFactoryDeps {
  getLogger: (sessionID: string) => Logger;
  directory: string;
  $: any;
}

export const registerPluginTools = ({ getLogger, directory, $ }: ToolFactoryDeps) => {
  return {
    say_hello: createSayHelloTool(getLogger),
    quick_shell: createQuickShellTool(getLogger, $),
    view_logs: createViewLogsTool(getLogger, directory),
    plugin_info: createPluginInfoTool(getLogger, directory),
  };
};



================================================
FILE: my-little-ui/src/tools/plugin-info.ts
================================================
import { tool } from "@opencode-ai/plugin";
import type { Logger } from "../utils/logger";
import { 
  getPluginName, 
  getPluginVersion, 
  getPluginDescription,
  getPluginTools,
  getPluginAgents,
  getPluginFeatures,
  getPluginStatus
} from "../plugin-info";

/**
 * Plugin Info Tool
 * 
 * Purpose: Provides comprehensive information about the plugin
 * 
 * This tool is self-documenting - it shows users:
 * - Plugin version and status
 * - Current environment details
 * - All available tools with examples
 * - Custom agents
 * - Plugin features
 * 
 * Function: createPluginInfoTool()
 * - Returns formatted plugin information
 * - Uses plugin-info module for version/status
 * - Helps users understand plugin capabilities
 */
export const createPluginInfoTool = (
  getLogger: (sessionID: string) => Logger,
  directory: string
) => {
  return tool({
    description: `Get information about the ${getPluginName()}`,
    args: {},
    async execute(args, context) {
      const logger = getLogger(context.sessionID);
      const status = getPluginStatus();
      const info: string[] = [];
      
      info.push(`# â„¹ï¸  ${getPluginName()} v${getPluginVersion()}`);
      info.push("");
      info.push(getPluginDescription());
      info.push("");
      info.push(`**Status:** ${status.emoji} ${status.message}`);
      info.push("");
      
      info.push("## ðŸ“ Current Environment");
      info.push("```");
      info.push(`Working Directory: ${directory}`);
      info.push(`Session ID: ${context.sessionID.slice(0, 8)}...`);
      info.push(`Active Agent: ${context.agent}`);
      info.push(`Message ID: ${context.messageID}`);
      info.push(`Log Directory: ${logger.getLogDir()}`);
      info.push("```");
      info.push("");
      
      info.push("## ðŸ› ï¸ Available Tools");
      info.push("");
      getPluginTools().forEach((tool, index) => {
        info.push(`### ${index + 1}. ${tool.name}`);
        info.push(tool.description);
        info.push("");
      });
      
      info.push("## ðŸ¤– Custom Agents");
      getPluginAgents().forEach((agent) => {
        info.push(`- **${agent.name}** - ${agent.description}`);
      });
      info.push("");
      
      info.push("## âœ¨ Plugin Features");
      getPluginFeatures().forEach((feature) => {
        info.push(`- ${feature}`);
      });
      info.push("");
      
      info.push("---");
      info.push(`*Powered by ${getPluginName()} ${status.emoji}*`);
      
      return info.join("\n");
    },
  });
};



================================================
FILE: my-little-ui/src/tools/quick-shell.ts
================================================
import { tool } from "@opencode-ai/plugin";
import type { Logger } from "../utils/logger";

/**
 * Quick Shell Tool
 * 
 * Purpose: Executes shell commands using Bun's shell API
 * Features:
 * - Runs any shell command
 * - Returns trimmed output
 * - Logs execution and errors
 * - Uses Bun's $ template literal for safe execution
 * 
 * Security Note: This tool executes arbitrary commands.
 * In production, consider adding command validation/whitelisting.
 */
export const createQuickShellTool = (
  getLogger: (sessionID: string) => Logger,
  $: any
) => {
  return tool({
    description: "Executes a shell command and returns the output",
    args: {
      command: tool.schema.string().describe("The shell command to execute"),
    },
    async execute(args, context) {
      const logger = getLogger(context.sessionID);
      logger.log("quick_shell called", { command: args.command });
      
      try {
        const result = await $`${args.command}`.text();
        logger.log("quick_shell success", { command: args.command });
        return result.trim();
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        logger.log("quick_shell error", { command: args.command, error: errorMsg });
        throw error;
      }
    },
  });
};



================================================
FILE: my-little-ui/src/tools/say-hello.ts
================================================
import { tool } from "@opencode-ai/plugin";
import type { Logger } from "../utils/logger";

/**
 * Say Hello Tool
 * 
 * Purpose: Demonstrates a simple custom tool that greets users
 * Features:
 * - Takes a name parameter
 * - Optional enthusiasm flag for extra excitement
 * - Logs all interactions
 */
export const createSayHelloTool = (getLogger: (sessionID: string) => Logger) => {
  return tool({
    description: "Says hello to someone with a custom message",
    args: {
      name: tool.schema.string().describe("The name of the person to greet"),
      enthusiastic: tool.schema
        .boolean()
        .optional()
        .describe("Whether to add extra enthusiasm"),
    },
    async execute(args, context) {
      const logger = getLogger(context.sessionID);
      logger.log("say_hello called", { name: args.name, enthusiastic: args.enthusiastic });
      
      const greeting = args.enthusiastic
        ? `HELLO ${args.name.toUpperCase()}! ðŸŽ‰ðŸŽ‰ðŸŽ‰`
        : `Hello, ${args.name}!`;
      
      logger.log("say_hello greeting generated", { greeting });
      
      return greeting;
    },
  });
};



================================================
FILE: my-little-ui/src/tools/view-logs.ts
================================================
import { tool } from "@opencode-ai/plugin";
import { Logger } from "../utils/logger";

/**
 * View Logs Tool
 * 
 * Purpose: Provides visibility into plugin logging system
 * Features:
 * - Shows current session ID
 * - Displays log directory location
 * - Lists all session logs
 * - Shows recent log entries (configurable number of lines)
 * - Provides helpful commands for log management
 */
export const createViewLogsTool = (
  getLogger: (sessionID: string) => Logger,
  directory: string
) => {
  return tool({
    description: "Show the log file location and recent log entries for the current session",
    args: {
      lines: tool.schema.number().optional().describe("Number of recent lines to show (default 50)"),
    },
    async execute(args, context) {
      const logger = getLogger(context.sessionID);
      const linesToShow = args.lines || 50;
      const logContent = logger.readLogs(linesToShow);
      const allSessions = Logger.getAllSessions(directory);
      
      return `# ðŸ“‹ Plugin Logs

**Current Session:** \`${context.sessionID}\`
**Log Directory:** \`${logger.getLogDir()}\`
**All Sessions:** ${allSessions.length} session log(s) found

**Recent Entries (last ${linesToShow} lines):**
\`\`\`
${logContent}
\`\`\`

**Log Files Location:**
- Current: \`${logger.getLogPath()}\`
- All logs: \`${logger.getLogDir()}\`

To view live logs: \`tail -f ${logger.getLogPath()}\`
To clean up: Delete the \`.tmp/my-little-plugin\` folder in your project`;
    },
  });
};



================================================
FILE: my-little-ui/src/utils/logger.ts
================================================
import * as fs from "fs";
import * as path from "path";

export class Logger {
  private logDir: string;
  private sessionID: string;
  private logFile: string;

  constructor(projectDir: string, sessionID: string) {
    this.sessionID = sessionID;
    this.logDir = path.join(projectDir, ".tmp", "my-little-plugin");
    this.logFile = path.join(this.logDir, `${sessionID}.log`);
    
    this.ensureLogDir();
    this.log("Session started");
  }

  private ensureLogDir(): void {
    try {
      if (!fs.existsSync(this.logDir)) {
        fs.mkdirSync(this.logDir, { recursive: true });
      }
    } catch {}
  }

  log(message: string, data?: unknown): void {
    try {
      const timestamp = new Date().toISOString();
      const dataStr = data ? ` ${JSON.stringify(data)}` : "";
      const logEntry = `[${timestamp}] ${message}${dataStr}\n`;
      fs.appendFileSync(this.logFile, logEntry);
    } catch {}
  }

  getLogPath(): string {
    return this.logFile;
  }

  getLogDir(): string {
    return this.logDir;
  }

  readLogs(lines: number = 50): string {
    try {
      const content = fs.readFileSync(this.logFile, "utf-8");
      const allLines = content.split("\n").filter(l => l.trim());
      const recentLines = allLines.slice(-lines);
      return recentLines.join("\n");
    } catch {
      return "No logs yet.";
    }
  }

  static getAllSessions(projectDir: string): string[] {
    try {
      const logDir = path.join(projectDir, ".tmp", "my-little-plugin");
      if (!fs.existsSync(logDir)) return [];
      return fs.readdirSync(logDir)
        .filter(f => f.endsWith(".log"))
        .map(f => f.replace(".log", ""));
    } catch {
      return [];
    }
  }
}



================================================
FILE: skills-plugin/README.md
================================================
# Skills Plugin with Event Hooks

## Overview

This is an **example implementation** of the OpenCode Skills Plugin that demonstrates how to use **event hooks** (`tool.execute.before` and `tool.execute.after`) to deliver skill content to agents.

## Purpose

This folder shows how to:
- âœ… Implement skills using event hooks
- âœ… Inject skill content before tool execution
- âœ… Enhance output after tool execution
- âœ… Use lookup maps for efficient access
- âœ… Keep tools focused and minimal

## Files

```
skills-plugin/
â”œâ”€â”€ example.ts (315 lines)
â”‚   â”œâ”€â”€ Skill interface definition
â”‚   â”œâ”€â”€ Validation schema (Zod)
â”‚   â”œâ”€â”€ Tool name generation
â”‚   â”œâ”€â”€ Skill parsing and discovery
â”‚   â”œâ”€â”€ Skill lookup map creation
â”‚   â”œâ”€â”€ Minimal tool definitions
â”‚   â”œâ”€â”€ tool.execute.before hook
â”‚   â”œâ”€â”€ tool.execute.after hook
â”‚   â””â”€â”€ Plugin return object
â”œâ”€â”€ README.md (this file)
â”œâ”€â”€ hook-lifecycle-and-patterns.md
â””â”€â”€ implementation-pattern.md
```

## Key Features

### 1. Skill Lookup Map
```typescript
const skillMap = new Map<string, Skill>()
for (const skill of skills) {
  skillMap.set(skill.toolName, skill)
}
```
- **Performance:** O(1) access instead of O(n) search
- **Efficiency:** Enables fast hook execution
- **Scalability:** Works with any number of skills

### 2. Minimal Tool Definition
```typescript
async execute() {
  return `Skill activated: ${skill.name}`
}
```
- **Focused:** Only returns confirmation
- **No side effects:** Delivery happens in hooks
- **Testable:** Easy to unit test

### 3. Before Hook: Skill Delivery
```typescript
const beforeHook = async (input: any) => {
  if (input.tool.startsWith("skills_")) {
    const skill = skillMap.get(input.tool)
    if (skill) {
      await ctx.client.session.prompt({
        path: { id: input.sessionID },
        body: {
          agent: input.agent,
          noReply: true,
          parts: [{ type: "text", text: `ðŸ“š Skill: ${skill.name}...` }],
        },
      })
    }
  }
}
```
- **Purpose:** Inject skill content
- **When:** Before tool execution
- **Effect:** Skill content persists in conversation

### 4. After Hook: Output Enhancement
```typescript
const afterHook = async (input: any, output: any) => {
  if (input.tool.startsWith("skills_")) {
    const skill = skillMap.get(input.tool)
    if (skill && output.output) {
      output.title = `ðŸ“š ${skill.name}`
    }
  }
}
```
- **Purpose:** Add visual feedback
- **When:** After tool execution
- **Effect:** Enhanced output with emoji title

## Architecture Pattern

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Tool called by agent                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. tool.execute.before hook fires       â”‚
â”‚    - Inject skill content               â”‚
â”‚    - Skill content persists             â”‚
â”‚    - No AI response triggered           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. Tool.execute() runs                  â”‚
â”‚    - Return confirmation                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. tool.execute.after hook fires        â”‚
â”‚    - Add emoji title                    â”‚
â”‚    - Could add logging/analytics        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. Result returned to agent             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## How Skills Work with Hooks

### Tool Definition

The skill tool is simple and focused:

```typescript
async execute() {
  return `Skill activated: ${skill.name}`
}
```

The tool just confirms activation. All skill delivery happens in hooks.

### Before Hook: Skill Delivery

When a skill tool is called, the `tool.execute.before` hook fires first:

```typescript
const beforeHook = async (input) => {
  if (input.tool.startsWith("skills_")) {
    const skill = skillMap.get(input.tool)
    if (skill) {
      // Inject skill content into conversation
      await ctx.client.session.prompt({
        path: { id: input.sessionID },
        body: {
          agent: input.agent,
          noReply: true,  // Don't trigger AI response
          parts: [{ type: "text", text: skill.content }],
        },
      })
    }
  }
}
```

**What happens:**
- Skill content is added to the conversation
- Agent can now see and use the skill
- No AI response is triggered (silent insertion)

### After Hook: Output Enhancement

After the tool executes, the `tool.execute.after` hook fires:

```typescript
const afterHook = async (input, output) => {
  if (input.tool.startsWith("skills_")) {
    const skill = skillMap.get(input.tool)
    if (skill && output.output) {
      output.title = `ðŸ“š ${skill.name}`
    }
  }
}
```

**What happens:**
- Output is enhanced with visual feedback
- User sees which skill was activated
- Could add logging or analytics here

## How to Use This Example

### 1. Understand the Implementation
- Read `example.ts` - See how skills are implemented
- Review comments - Understand each section
- Study the hooks - See how they work together

### 2. Learn the Key Components
- **Skill lookup map:** Fast O(1) access to skills
- **Minimal tools:** Tools only return confirmation
- **Before hook:** Injects skill content
- **After hook:** Enhances output with feedback

### 3. Adapt for Your Use Case
1. Create tools for your features
2. Build a lookup map for your data
3. Use `tool.execute.before` to inject context
4. Use `tool.execute.after` to enhance output
5. Keep tools simple and focused

## Related Documentation

### In This Project
- `hook-lifecycle-and-patterns.md` - Visual guide to hook lifecycle
- `implementation-pattern.md` - How to implement hooks in your plugin
- `context/capabilities/events_skills.md` - Practical event hook examples

### In Context Library
- `context/capabilities/events.md` - All available events
- `context/capabilities/tools.md` - Tool definition guide
- `context/reference/best-practices.md` - Best practices

### Reference Implementation
- `my-little-ui/src/hooks/` - Working reference with hooks

## Key Takeaways

1. **Hooks are middleware** - Intercept at specific points
2. **Separation of concerns** - Tools do one thing, hooks do another
3. **Lookup maps** - Enable O(1) access instead of O(n)
4. **Minimal tools** - Keep tools focused and testable
5. **SOLID principles** - Maintain Single Responsibility
6. **Composability** - Hooks can be combined with other plugins
7. **Testability** - Each component can be tested independently
8. **Maintainability** - Changes are isolated to specific hooks

## Code Quality

- âœ… SOLID principles compliant
- âœ… Single Responsibility Principle maintained
- âœ… Loose coupling (hooks separate from tools)
- âœ… High cohesion (related logic grouped)
- âœ… Well-documented with comments
- âœ… Performance optimized (O(1) lookup)

## Next Steps

### Optional Enhancements
1. Extract hooks to separate `hooks.ts` file
2. Add logging to skill delivery
3. Add unit tests for hooks
4. Add error handling
5. Create skills plugin package

### Learning Path
1. Study `example.ts` - Understand the code
2. Read `implementation-pattern.md` - Understand the pattern
3. Review `hook-lifecycle-and-patterns.md` - Learn best practices
4. Study `my-little-ui/src/hooks/` - See working reference
5. Implement in your own plugin

## Questions?

Refer to:
- `implementation-pattern.md` - For detailed explanations
- `hook-lifecycle-and-patterns.md` - For visual guides
- `context/capabilities/events_skills.md` - For practical examples
- `my-little-ui/src/hooks/` - For reference implementation

---

**Status:** âœ… Example Implementation  
**Quality:** âœ… SOLID Compliant  
**Documentation:** âœ… Comprehensive  

This is an example of how to implement skills with event hooks.




================================================
FILE: skills-plugin/example.ts
================================================
/**
 * OpenCode Skills Plugin (Refactored)
 *
 * Implements Anthropic's Agent Skills Specification (v1.0) for OpenCode.
 *
 * Features:
 * - Discovers SKILL.md files from .opencode/skills/, ~/.opencode/skills/, and ~/.config/opencode/skills/
 * - Validates skills against Anthropic's spec (YAML frontmatter + Markdown)
 * - Registers dynamic tools with pattern skills_{{skill_name}}
 * - Delivers skill content via hook-based silent message insertion
 * - Supports nested skills with proper naming
 *
 * Architecture:
 * - Tool definitions are minimal and focused (no side effects)
 * - Skill delivery happens in tool.execute.before hook (separation of concerns)
 * - Tool output enhancement happens in tool.execute.after hook
 * - Skill lookup map enables O(1) access in hooks
 *
 * Design Decisions:
 * - Tool restrictions handled at agent level (not skill level)
 * - Hook-based delivery ensures skill content persists (user messages not purged)
 * - Base directory context enables relative path resolution
 * - Skills require restart to reload (acceptable trade-off)
 * - Hooks separate concerns: tool logic vs. delivery mechanism
 *
 * @see https://github.com/anthropics/skills
 */

import type { Plugin } from "@opencode-ai/plugin"
import { tool } from "@opencode-ai/plugin"
import matter from "gray-matter"
import { Glob } from "bun"
import { join, dirname, basename, relative, sep } from "path"
import { z } from "zod"
import os from "os"

// Types (exported for testing)
export interface Skill {
  name: string // From frontmatter (e.g., "brand-guidelines")
  fullPath: string // Full directory path to skill
  toolName: string // Generated tool name (e.g., "skills_brand_guidelines")
  description: string // From frontmatter
  allowedTools?: string[] // Parsed but not enforced (agent-level restrictions instead)
  metadata?: Record<string, string>
  license?: string
  content: string // Markdown body
  path: string // Full path to SKILL.md
}

// Validation Schema
const SkillFrontmatterSchema = z.object({
  name: z
    .string()
    .regex(/^[a-z0-9-]+$/, "Name must be lowercase alphanumeric with hyphens")
    .min(1, "Name cannot be empty"),
  description: z.string().min(20, "Description must be at least 20 characters for discoverability"),
  license: z.string().optional(),
  "allowed-tools": z.array(z.string()).optional(),
  metadata: z.record(z.string(), z.string()).optional(),
})

type SkillFrontmatter = z.infer<typeof SkillFrontmatterSchema>

/**
 * Generate tool name from skill path
 * Examples:
 *   .opencode/skills/brand-guidelines/SKILL.md â†’ skills_brand_guidelines
 *   .opencode/skills/document-skills/docx/SKILL.md â†’ skills_document_skills_docx
 */
function generateToolName(skillPath: string, baseDir: string): string {
  const rel = relative(baseDir, skillPath)
  const dirPath = dirname(rel)
  const components = dirPath.split(sep).filter((c) => c !== ".")
  return "skills_" + components.join("_").replace(/-/g, "_")
}

/**
 * Parse a SKILL.md file and return structured skill data
 * Returns null if parsing fails (with error logging)
 */
async function parseSkill(skillPath: string, baseDir: string): Promise<Skill | null> {
  try {
    // Read file
    const content = await Bun.file(skillPath).text()

    // Parse YAML frontmatter
    const { data, content: markdown } = matter(content)

    // Validate frontmatter schema
    let frontmatter: SkillFrontmatter
    try {
      frontmatter = SkillFrontmatterSchema.parse(data)
    } catch (error) {
      if (error instanceof z.ZodError) {
        console.error(`âŒ Invalid frontmatter in ${skillPath}:`)
        error.issues.forEach((err: any) => {
          console.error(`   - ${err.path.join(".")}: ${err.message}`)
        })
      }
      return null
    }

    // Validate name matches directory
    const skillDir = basename(dirname(skillPath))
    if (frontmatter.name !== skillDir) {
      console.error(
        `âŒ Name mismatch in ${skillPath}:`,
        `\n   Frontmatter name: "${frontmatter.name}"`,
        `\n   Directory name: "${skillDir}"`,
        `\n   Fix: Update the 'name' field in SKILL.md to match the directory name`
      )
      return null
    }

    // Generate tool name from path
    const toolName = generateToolName(skillPath, baseDir)

    return {
      name: frontmatter.name,
      fullPath: dirname(skillPath),
      toolName,
      description: frontmatter.description,
      allowedTools: frontmatter["allowed-tools"],
      metadata: frontmatter.metadata as Record<string, string> | undefined,
      license: frontmatter.license,
      content: markdown.trim(),
      path: skillPath,
    }
  } catch (error) {
    console.error(
      `âŒ Error parsing skill ${skillPath}:`,
      error instanceof Error ? error.message : String(error)
    )
    return null
  }
}

/**
 * Discover all skills from the given base paths
 */
async function discoverSkills(basePaths: string[]): Promise<Skill[]> {
  const skills: Skill[] = []
  let foundPath = false

  for (const basePath of basePaths) {
    try {
      // Find all SKILL.md files recursively (following symlinks)
      const glob = new Glob("**/SKILL.md")
      for await (const match of glob.scan({
        cwd: basePath,
        absolute: true,
        followSymlinks: true,
      })) {
        const skill = await parseSkill(match, basePath)
        if (skill) {
          skills.push(skill)
        }
      }

      foundPath = true
    } catch (error) {
      if (
        error &&
        typeof error === "object" &&
        "code" in error &&
        (error as any).code === "ENOENT"
      ) {
        // Directory does not exist, expected in some cases
      } else {
        console.warn(`Unexpected error while scanning skills in ${basePath}:`, error)
      }
    }
  }

  if (!foundPath) {
    console.warn(
      `Could not find any skills directories. Tried:`,
      ...basePaths.map((path) => `\n     ${path}`),
      `\n   This is normal if none of the directories exist yet.`
    )
  }

  // Detect duplicate tool names
  const toolNames = new Set<string>()
  const duplicates = []

  for (const skill of skills) {
    if (toolNames.has(skill.toolName)) {
      duplicates.push(skill.toolName)
    }
    toolNames.add(skill.toolName)
  }

  if (duplicates.length > 0) {
    console.warn(`âš ï¸ Duplicate tool names detected:`, duplicates)
  }

  return skills
}

export const SkillsPlugin: Plugin = async (ctx: any) => {
  // Determine config path: $XDG_CONFIG_HOME/opencode/skills or ~/.config/opencode/skills
  const xdgConfigHome = process.env.XDG_CONFIG_HOME
  const configSkillsPath = xdgConfigHome
    ? join(xdgConfigHome, "opencode/skills")
    : join(os.homedir(), ".config/opencode/skills")

  // Allow skills to be loaded from OPENCODE_CONFIG_DIR (custom OpenCode config dir)
  const opencodeConfigDir = process.env.OPENCODE_CONFIG_DIR

  // Discovery order: lowest to highest priority (last wins on duplicate tool names)
  const skills = await discoverSkills(
    [
      configSkillsPath, // Lowest priority: XDG config
      join(os.homedir(), ".opencode/skills"), // Medium priority: Global home
      opencodeConfigDir && join(opencodeConfigDir, "skills"), // Medium-high priority: Custom config
      join(ctx.directory, ".opencode/skills"), // Highest priority: Project-local
    ].filter((p): p is string => Boolean(p))
  )

  // ============================================================================
  // STEP 1: Create skill lookup map for O(1) access in hooks
  // ============================================================================
  // This map enables efficient skill retrieval during hook execution
  // Key: toolName (e.g., "skills_brand_guidelines")
  // Value: Skill object with all metadata and content
  const skillMap = new Map<string, Skill>()
  for (const skill of skills) {
    skillMap.set(skill.toolName, skill)
  }

  // ============================================================================
  // STEP 2: Create minimal tool definitions (no side effects)
  // ============================================================================
  // Tools are now simple and focused - they only return confirmation
  // All skill delivery logic is moved to hooks (see below)
  const tools: Record<string, any> = {}

  for (const skill of skills) {
    tools[skill.toolName] = tool({
      description: skill.description,
      args: {}, // No args for MVP - can add template args later
      async execute() {
        // Minimal return - skill delivery happens in hooks
        return `Skill activated: ${skill.name}`
      },
    })
  }

  // ============================================================================
  // STEP 3: Create tool.execute.before hook for skill delivery
  // ============================================================================
  // This hook runs BEFORE any skill tool executes
  // Purpose: Inject skill content via silent message insertion
  // Why hooks? Separates delivery mechanism from tool logic
  const beforeHook = async (input: any) => {
    // Check if this is a skill tool (all skill tools start with "skills_")
    if (input.tool.startsWith("skills_")) {
      const skill = skillMap.get(input.tool)
      if (skill) {
        // Send skill content as silent prompt (noReply: true)
        // This ensures the skill content persists in the conversation
        // without triggering an AI response
        await ctx.client.session.prompt({
          path: { id: input.sessionID },
          body: {
            agent: input.agent,
            noReply: true,
            parts: [
              {
                type: "text",
                text: `ðŸ“š Skill: ${skill.name}\nBase directory: ${skill.fullPath}\n\n${skill.content}`,
              },
            ],
          },
        })
      }
    }
  }

  // ============================================================================
  // STEP 4: Create tool.execute.after hook for output enhancement
  // ============================================================================
  // This hook runs AFTER any skill tool completes
  // Purpose: Add visual feedback and logging
  // Why hooks? Allows cross-cutting concerns without modifying tool logic
  const afterHook = async (input: any, output: any) => {
    // Check if this is a skill tool
    if (input.tool.startsWith("skills_")) {
      const skill = skillMap.get(input.tool)
      if (skill && output.output) {
        // Add emoji title for visual feedback
        output.title = `ðŸ“š ${skill.name}`
        // Could add logging here: console.log(`âœ… Skill delivered: ${skill.name}`)
      }
    }
  }

  // ============================================================================
  // PLUGIN RETURN OBJECT
  // ============================================================================
  // Register tools and hooks following OpenCode plugin pattern
  return {
    // Custom tools that agents can call
    tool: tools,

    // Hook: Runs before tool execution
    // Used for: Skill content injection, validation, preprocessing
    "tool.execute.before": beforeHook,

    // Hook: Runs after tool execution
    // Used for: Output enhancement, logging, analytics
    "tool.execute.after": afterHook,
  }
}



================================================
FILE: skills-plugin/hook-lifecycle-and-patterns.md
================================================
# OpenCode Hook Architecture Guide

## Visual Overview

### Tool Execution Lifecycle with Hooks

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    AGENT CALLS SKILL TOOL                       â”‚
â”‚                  (e.g., skills_brand_guidelines)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  HOOK: tool.execute.before                      â”‚
â”‚                                                                 â”‚
â”‚  Purpose: Preprocessing & Context Injection                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ 1. Check if tool is a skill (starts with "skills_")    â”‚   â”‚
â”‚  â”‚ 2. Look up skill in skillMap (O(1) access)             â”‚   â”‚
â”‚  â”‚ 3. Inject skill content via silent prompt              â”‚   â”‚
â”‚  â”‚ 4. Skill content persists in conversation              â”‚   â”‚
â”‚  â”‚ 5. No AI response triggered (noReply: true)            â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚
â”‚  Code:                                                          â”‚
â”‚  const beforeHook = async (input, output) => {                 â”‚
â”‚    if (input.tool.startsWith("skills_")) {                     â”‚
â”‚      const skill = skillMap.get(input.tool)                    â”‚
â”‚      if (skill) {                                              â”‚
â”‚        await ctx.client.session.prompt({                       â”‚
â”‚          path: { id: input.sessionID },                        â”‚
â”‚          body: {                                               â”‚
â”‚            agent: input.agent,                                 â”‚
â”‚            noReply: true,                                      â”‚
â”‚            parts: [{ type: "text", text: skill.content }]      â”‚
â”‚          }                                                      â”‚
â”‚        })                                                       â”‚
â”‚      }                                                          â”‚
â”‚    }                                                            â”‚
â”‚  }                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TOOL.EXECUTE() RUNS                          â”‚
â”‚                                                                 â”‚
â”‚  Purpose: Core Tool Logic (Minimal)                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ async execute(args, toolCtx) {                          â”‚   â”‚
â”‚  â”‚   return `Skill activated: ${skill.name}`               â”‚   â”‚
â”‚  â”‚ }                                                        â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚
â”‚  Why minimal?                                                   â”‚
â”‚  - No side effects                                              â”‚
â”‚  - Easy to test                                                 â”‚
â”‚  - Delivery happens in hooks, not here                          â”‚
â”‚  - Single responsibility                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  HOOK: tool.execute.after                       â”‚
â”‚                                                                 â”‚
â”‚  Purpose: Output Enhancement & Monitoring                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ 1. Check if tool is a skill                            â”‚   â”‚
â”‚  â”‚ 2. Look up skill in skillMap                           â”‚   â”‚
â”‚  â”‚ 3. Add emoji title to output                           â”‚   â”‚
â”‚  â”‚ 4. Could add logging/analytics here                    â”‚   â”‚
â”‚  â”‚ 5. Modify output.title for visual feedback             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚
â”‚  Code:                                                          â”‚
â”‚  const afterHook = async (input, output) => {                  â”‚
â”‚    if (input.tool.startsWith("skills_")) {                     â”‚
â”‚      const skill = skillMap.get(input.tool)                    â”‚
â”‚      if (skill && output.output) {                             â”‚
â”‚        output.title = `ðŸ“š ${skill.name}`                       â”‚
â”‚      }                                                          â”‚
â”‚    }                                                            â”‚
â”‚  }                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  RESULT RETURNED TO AGENT                       â”‚
â”‚                                                                 â”‚
â”‚  - Tool confirmation message                                    â”‚
â”‚  - Skill content in conversation history                        â”‚
â”‚  - Enhanced output with emoji title                             â”‚
â”‚  - Agent can now use skill content in reasoning                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Architecture Comparison

### âŒ OLD: Embedded Delivery (Anti-Pattern)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Tool Definition                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ async execute(args, toolCtx) {           â”‚
â”‚   // Parse arguments                     â”‚
â”‚   // Validate inputs                     â”‚
â”‚   // Execute core logic                  â”‚
â”‚   // âŒ Inject skill content             â”‚
â”‚   // âŒ Format output                    â”‚
â”‚   // âŒ Add visual feedback              â”‚
â”‚   return result                          â”‚
â”‚ }                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
    PROBLEMS:
    - Tight coupling
    - Hard to test
    - Violates SOLID
    - No reusability
    - Difficult to monitor
```

### âœ… NEW: Hook-Based Delivery (Best Practice)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    tool.execute.before Hook              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ - Inject skill content                   â”‚
â”‚ - Validate inputs                        â”‚
â”‚ - Preprocess arguments                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Tool Definition (Minimal)           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ async execute(args, toolCtx) {           â”‚
â”‚   // Parse arguments                     â”‚
â”‚   // Validate inputs                     â”‚
â”‚   // Execute core logic                  â”‚
â”‚   return result                          â”‚
â”‚ }                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    tool.execute.after Hook               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ - Format output                          â”‚
â”‚ - Add visual feedback                    â”‚
â”‚ - Log completion                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    BENEFITS:
    âœ… Loose coupling
    âœ… Easy to test
    âœ… SOLID compliant
    âœ… Highly reusable
    âœ… Easy to monitor
```

---

## Hook Types & Use Cases

### tool.execute.before

**When it fires:** Before the tool function runs

**What you can do:**
- âœ… Inject context (like skill content)
- âœ… Validate inputs
- âœ… Preprocess arguments
- âœ… Log tool calls
- âœ… Implement security checks
- âœ… Modify arguments before execution

**What you can't do:**
- âŒ Modify tool output (tool hasn't run yet)
- âŒ Access tool results

**Example:**
```typescript
const beforeHook = async (input, output) => {
  // input.tool: tool name
  // input.sessionID: session ID
  // input.agent: agent name
  // output.args: tool arguments
  
  if (input.tool.startsWith("skills_")) {
    const skill = skillMap.get(input.tool)
    if (skill) {
      // Inject skill content
      await ctx.client.session.prompt({...})
    }
  }
}
```

---

### tool.execute.after

**When it fires:** After the tool function completes

**What you can do:**
- âœ… Modify output
- âœ… Add titles/formatting
- âœ… Log completion
- âœ… Add analytics
- âœ… Transform results
- âœ… Add visual feedback

**What you can't do:**
- âŒ Modify tool arguments (already executed)
- âŒ Prevent tool execution (already happened)

**Example:**
```typescript
const afterHook = async (input, output) => {
  // input.tool: tool name
  // input.sessionID: session ID
  // output.output: tool result
  // output.title: can be modified
  
  if (input.tool.startsWith("skills_")) {
    const skill = skillMap.get(input.tool)
    if (skill && output.output) {
      output.title = `ðŸ“š ${skill.name}`
    }
  }
}
```

---

## Skill Lookup Map: Why It Matters

### Problem: O(n) Search

```typescript
// âŒ OLD: Search through array every time
const beforeHook = async (input, output) => {
  if (input.tool.startsWith("skills_")) {
    // Search through all skills
    const skill = skills.find(s => s.toolName === input.tool)
    if (skill) {
      // Use skill
    }
  }
}

// Performance: O(n) where n = number of skills
// With 100 skills: 100 comparisons per hook call
```

### Solution: O(1) Lookup

```typescript
// âœ… NEW: Direct map lookup
const skillMap = new Map<string, Skill>()
for (const skill of skills) {
  skillMap.set(skill.toolName, skill)
}

const beforeHook = async (input, output) => {
  if (input.tool.startsWith("skills_")) {
    // Direct lookup
    const skill = skillMap.get(input.tool)
    if (skill) {
      // Use skill
    }
  }
}

// Performance: O(1) constant time
// With 100 skills: 1 lookup per hook call
```

**Impact:**
- 100 skills: 100x faster
- 1000 skills: 1000x faster
- Scales linearly with number of skills

---

## Plugin Return Object

```typescript
return {
  // Custom tools that agents can call
  tool: tools,

  // Hook: Runs before tool execution
  // Used for: Context injection, validation, preprocessing
  "tool.execute.before": beforeHook,

  // Hook: Runs after tool execution
  // Used for: Output enhancement, logging, analytics
  "tool.execute.after": afterHook,
}
```

**Key points:**
- `tool`: Object with tool definitions
- `"tool.execute.before"`: Function that runs before each tool
- `"tool.execute.after"`: Function that runs after each tool
- Hooks apply to ALL tools, so use `if` statements to filter

---

## Real-World Example: Skills Plugin

### Setup

```typescript
// 1. Discover skills
const skills = await discoverSkills([...paths])

// 2. Create lookup map
const skillMap = new Map<string, Skill>()
for (const skill of skills) {
  skillMap.set(skill.toolName, skill)
}

// 3. Create minimal tools
const tools: Record<string, any> = {}
for (const skill of skills) {
  tools[skill.toolName] = tool({
    description: skill.description,
    args: {},
    async execute(args, toolCtx) {
      return `Skill activated: ${skill.name}`
    },
  })
}
```

### Before Hook: Skill Delivery

```typescript
const beforeHook = async (input: any, output: any) => {
  // Only process skill tools
  if (input.tool.startsWith("skills_")) {
    const skill = skillMap.get(input.tool)
    if (skill) {
      // Inject skill content as silent prompt
      await ctx.client.session.prompt({
        path: { id: input.sessionID },
        body: {
          agent: input.agent,
          noReply: true,  // Don't trigger AI response
          parts: [
            {
              type: "text",
              text: `ðŸ“š Skill: ${skill.name}\nBase directory: ${skill.fullPath}\n\n${skill.content}`,
            },
          ],
        },
      })
    }
  }
}
```

### After Hook: Output Enhancement

```typescript
const afterHook = async (input: any, output: any) => {
  // Only process skill tools
  if (input.tool.startsWith("skills_")) {
    const skill = skillMap.get(input.tool)
    if (skill && output.output) {
      // Add emoji title for visual feedback
      output.title = `ðŸ“š ${skill.name}`
    }
  }
}
```

### Plugin Return

```typescript
return {
  tool: tools,
  "tool.execute.before": beforeHook,
  "tool.execute.after": afterHook,
}
```

---

## Testing Hooks

### Testing Before Hook

```typescript
describe("beforeHook", () => {
  it("should inject skill content for skill tools", async () => {
    const input = { tool: "skills_brand_guidelines", sessionID: "test" }
    const output = { args: {} }
    
    const mockPrompt = jest.fn()
    ctx.client.session.prompt = mockPrompt
    
    await beforeHook(input, output)
    
    expect(mockPrompt).toHaveBeenCalledWith(
      expect.objectContaining({
        body: expect.objectContaining({
          noReply: true,
        }),
      })
    )
  })

  it("should skip non-skill tools", async () => {
    const input = { tool: "read_file", sessionID: "test" }
    const output = { args: {} }
    
    const mockPrompt = jest.fn()
    ctx.client.session.prompt = mockPrompt
    
    await beforeHook(input, output)
    
    expect(mockPrompt).not.toHaveBeenCalled()
  })
})
```

### Testing After Hook

```typescript
describe("afterHook", () => {
  it("should add emoji title for skill tools", async () => {
    const input = { tool: "skills_brand_guidelines" }
    const output = { output: "Skill activated" }
    
    await afterHook(input, output)
    
    expect(output.title).toBe("ðŸ“š brand-guidelines")
  })

  it("should skip non-skill tools", async () => {
    const input = { tool: "read_file" }
    const output = { output: "File content" }
    
    await afterHook(input, output)
    
    expect(output.title).toBeUndefined()
  })
})
```

---

## Common Patterns

### Pattern 1: Tool-Specific Hooks

```typescript
const beforeHook = async (input, output) => {
  switch (input.tool) {
    case "skills_brand_guidelines":
      // Handle brand guidelines
      break
    case "skills_api_reference":
      // Handle API reference
      break
    default:
      // Skip non-skill tools
  }
}
```

### Pattern 2: Conditional Processing

```typescript
const beforeHook = async (input, output) => {
  if (input.tool.startsWith("skills_")) {
    const skill = skillMap.get(input.tool)
    if (skill && skill.allowedTools?.includes(input.agent)) {
      // Process only if allowed
    }
  }
}
```

### Pattern 3: Logging & Monitoring

```typescript
const beforeHook = async (input, output) => {
  console.log(`[BEFORE] Tool: ${input.tool}`)
  console.log(`[BEFORE] Args:`, output.args)
}

const afterHook = async (input, output) => {
  console.log(`[AFTER] Tool: ${input.tool}`)
  console.log(`[AFTER] Result:`, output.output)
}
```

### Pattern 4: Error Handling

```typescript
const beforeHook = async (input, output) => {
  try {
    if (input.tool.startsWith("skills_")) {
      const skill = skillMap.get(input.tool)
      if (!skill) {
        throw new Error(`Skill not found: ${input.tool}`)
      }
      // Process skill
    }
  } catch (error) {
    console.error(`Hook error:`, error)
    // Don't rethrow - let tool execute anyway
  }
}
```

---

## Key Takeaways

1. **Hooks are middleware**: They intercept tool execution at specific points
2. **Before hook**: For preprocessing, validation, context injection
3. **After hook**: For output enhancement, logging, analytics
4. **Lookup maps**: Enable O(1) access instead of O(n) search
5. **Separation of concerns**: Tools do one thing, hooks do another
6. **Composability**: Multiple plugins can register hooks without conflict
7. **Testability**: Each component can be tested independently
8. **Maintainability**: Changes are isolated to specific hooks

---

## References

- **OpenCode Events**: `context/capabilities/events.md`
- **Best Practices**: `context/reference/best-practices.md`
- **Skills Plugin**: `index.ts`
- **my-little-ui Plugin**: `my-little-ui/src/hooks/`




================================================
FILE: skills-plugin/implementation-pattern.md
================================================
# Implementation Pattern: Using Event Hooks

## Overview

This document explains how to implement event hooks in your OpenCode plugin. The Skills Plugin demonstrates this pattern with `tool.execute.before` and `tool.execute.after` hooks.

---

## What Are Event Hooks?

Event hooks are functions that run at specific points in the tool execution lifecycle:

- **`tool.execute.before`** - Runs before a tool executes
- **`tool.execute.after`** - Runs after a tool completes

They allow you to:
- Inject context before execution
- Enhance output after execution
- Log tool usage
- Validate inputs
- Transform results

---

## Basic Hook Structure

### Before Hook

```typescript
const beforeHook = async (input: any, output: any) => {
  // input.tool - tool name
  // input.sessionID - session ID
  // input.agent - agent name
  // output.args - tool arguments
  
  if (input.tool === "my_tool") {
    // Do something before tool runs
  }
}
```

### After Hook

```typescript
const afterHook = async (input: any, output: any) => {
  // input.tool - tool name
  // input.sessionID - session ID
  // output.output - tool result
  // output.title - can be modified
  
  if (input.tool === "my_tool") {
    // Do something after tool runs
  }
}
```

---

## Skills Plugin Example

### Skill Lookup Map

First, create a map for fast access to your data:

```typescript
const skillMap = new Map<string, Skill>()
for (const skill of skills) {
  skillMap.set(skill.toolName, skill)
}
```

**Why?** O(1) lookup instead of O(n) search.

### Tool Definition

Keep tools simple and focused:

```typescript
tools[skill.toolName] = tool({
  description: skill.description,
  args: {},
  async execute() {
    return `Skill activated: ${skill.name}`
  },
})
```

### Before Hook: Inject Skill Content

```typescript
const beforeHook = async (input: any) => {
  if (input.tool.startsWith("skills_")) {
    const skill = skillMap.get(input.tool)
    if (skill) {
      await ctx.client.session.prompt({
        path: { id: input.sessionID },
        body: {
          agent: input.agent,
          noReply: true,
          parts: [
            {
              type: "text",
              text: `ðŸ“š Skill: ${skill.name}\n\n${skill.content}`,
            },
          ],
        },
      })
    }
  }
}
```

**What it does:**
- Checks if tool is a skill
- Looks up skill in map
- Injects skill content into conversation
- `noReply: true` prevents AI response

### After Hook: Enhance Output

```typescript
const afterHook = async (input: any, output: any) => {
  if (input.tool.startsWith("skills_")) {
    const skill = skillMap.get(input.tool)
    if (skill && output.output) {
      output.title = `ðŸ“š ${skill.name}`
    }
  }
}
```

**What it does:**
- Checks if tool is a skill
- Looks up skill in map
- Adds emoji title to output
- Provides visual feedback

### Register Hooks

```typescript
return {
  tool: tools,
  "tool.execute.before": beforeHook,
  "tool.execute.after": afterHook,
}
```

---

## Common Patterns

### Pattern 1: Tool-Specific Hooks

```typescript
const beforeHook = async (input, output) => {
  switch (input.tool) {
    case "skill_1":
      // Handle skill 1
      break
    case "skill_2":
      // Handle skill 2
      break
    default:
      // Skip other tools
  }
}
```

### Pattern 2: Prefix-Based Filtering

```typescript
const beforeHook = async (input, output) => {
  if (input.tool.startsWith("skills_")) {
    // Handle all skill tools
  }
}
```

### Pattern 3: Conditional Processing

```typescript
const beforeHook = async (input, output) => {
  if (input.tool.startsWith("skills_")) {
    const skill = skillMap.get(input.tool)
    if (skill && skill.enabled) {
      // Process only if enabled
    }
  }
}
```

### Pattern 4: Logging

```typescript
const beforeHook = async (input, output) => {
  console.log(`[BEFORE] Tool: ${input.tool}`)
  console.log(`[BEFORE] Args:`, output.args)
}

const afterHook = async (input, output) => {
  console.log(`[AFTER] Tool: ${input.tool}`)
  console.log(`[AFTER] Result:`, output.output)
}
```

### Pattern 5: Error Handling

```typescript
const beforeHook = async (input, output) => {
  try {
    if (input.tool === "my_tool") {
      const data = dataMap.get(input.tool)
      if (!data) {
        throw new Error(`Data not found: ${input.tool}`)
      }
      // Process
    }
  } catch (error) {
    console.error(`Hook error:`, error)
    // Don't rethrow - let tool execute anyway
  }
}
```

---

## Hook Execution Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Agent calls tool                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. tool.execute.before hook fires       â”‚
â”‚    - Inject context                     â”‚
â”‚    - Validate inputs                    â”‚
â”‚    - Preprocess arguments               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. Tool.execute() runs                  â”‚
â”‚    - Execute core logic                 â”‚
â”‚    - Return result                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. tool.execute.after hook fires        â”‚
â”‚    - Format output                      â”‚
â”‚    - Add visual feedback                â”‚
â”‚    - Log completion                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. Result returned to agent             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## When to Use Each Hook

### Use `tool.execute.before` for:
- âœ… Input validation
- âœ… Context injection (like skills)
- âœ… Argument preprocessing
- âœ… Security checks
- âœ… Logging tool calls

### Use `tool.execute.after` for:
- âœ… Output formatting
- âœ… Visual feedback (emoji titles)
- âœ… Logging completion
- âœ… Analytics
- âœ… Result transformation

---

## Performance Considerations

### Lookup Map: O(1) vs O(n)

**Inefficient (O(n)):**
```typescript
const beforeHook = async (input, output) => {
  const skill = skills.find(s => s.toolName === input.tool)
  // With 100 skills: 100 comparisons
  // With 1000 skills: 1000 comparisons
}
```

**Efficient (O(1)):**
```typescript
const skillMap = new Map<string, Skill>()
for (const skill of skills) {
  skillMap.set(skill.toolName, skill)
}

const beforeHook = async (input, output) => {
  const skill = skillMap.get(input.tool)
  // With 100 skills: 1 lookup
  // With 1000 skills: 1 lookup
}
```

**Impact:**
- 100 items: 100x faster
- 1000 items: 1000x faster

---

## Testing Hooks

### Testing Before Hook

```typescript
describe("beforeHook", () => {
  it("should inject context for matching tools", async () => {
    const input = { tool: "skills_test", sessionID: "test" }
    const output = { args: {} }

    const mockPrompt = jest.fn()
    ctx.client.session.prompt = mockPrompt

    await beforeHook(input, output)

    expect(mockPrompt).toHaveBeenCalled()
  })

  it("should skip non-matching tools", async () => {
    const input = { tool: "other_tool", sessionID: "test" }
    const output = { args: {} }

    const mockPrompt = jest.fn()
    ctx.client.session.prompt = mockPrompt

    await beforeHook(input, output)

    expect(mockPrompt).not.toHaveBeenCalled()
  })
})
```

### Testing After Hook

```typescript
describe("afterHook", () => {
  it("should enhance output for matching tools", async () => {
    const input = { tool: "skills_test" }
    const output = { output: "result" }

    await afterHook(input, output)

    expect(output.title).toBeDefined()
  })

  it("should skip non-matching tools", async () => {
    const input = { tool: "other_tool" }
    const output = { output: "result" }

    await afterHook(input, output)

    expect(output.title).toBeUndefined()
  })
})
```

---

## Key Takeaways

1. **Hooks are middleware** - Intercept at specific execution points
2. **Before hook** - For preprocessing and context injection
3. **After hook** - For output enhancement and logging
4. **Lookup maps** - Enable O(1) access instead of O(n)
5. **Keep tools simple** - Let hooks handle side effects
6. **Composability** - Hooks can be combined with other plugins
7. **Testability** - Each component can be tested independently
8. **Performance** - Use efficient data structures

---

## Next Steps

1. Study `index.ts` - See the full implementation
2. Review `hook-lifecycle-and-patterns.md` - Visual guide
3. Check `context/capabilities/events_skills.md` - Practical examples
4. Implement in your own plugin
5. Test thoroughly

---

## References

- **OpenCode Events:** `context/capabilities/events.md`
- **Hook Lifecycle:** `hook-lifecycle-and-patterns.md`
- **Practical Examples:** `context/capabilities/events_skills.md`
- **Reference Implementation:** `my-little-ui/src/hooks/`

---

**Status:** âœ… Implementation Guide  
**Quality:** âœ… Production Ready  
**Documentation:** âœ… Comprehensive  

Use this pattern when implementing hooks in your plugins.




================================================
FILE: skills-plugin/package.json
================================================
{
  "name": "@opencode/skills-plugin",
  "version": "1.0.0",
  "type": "module",
  "dependencies": {
    "@opencode-ai/plugin": "^1.0.189",
    "gray-matter": "^4.0.3",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "bun-types": "latest"
  }
}



================================================
FILE: skills-plugin/tsconfig.json
================================================
{
  "compilerOptions": {
    "lib": ["ESNext"],
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "types": ["bun-types"]
  }
}



================================================
FILE: .opencode/opencode.json
================================================
{
    "$schema": "https://opencode.ai/config.json",
    "plugin": [
     "my-little-ui"
    ],
    "agent": {
      "explore": {
        "disable": true
      }
    }
  }



================================================
FILE: .opencode/agent/codebase-agent.md
================================================
---
id: codebase-agent
name: Codebase Agent
description: "Multi-language implementation agent for modular and functional development"
category: development
type: standard
version: 1.0.0
author: opencode
mode: primary
temperature: 0.1
subagents:
tools:
  read: true
  edit: true
  write: true
  grep: true
  glob: true
  bash: true
  patch: true
allowed_subagents:
  - general
  - task 
permissions:
  bash:
    "rm -rf *": "ask"
    "sudo *": "deny"
    "chmod *": "ask"
    "curl *": "ask"
    "wget *": "ask"
    "docker *": "ask"
    "kubectl *": "ask"
  edit:
    "**/*.env*": "deny"
    "**/*.key": "deny"
    "**/*.secret": "deny"
    "node_modules/**": "deny"
    "**/__pycache__/**": "deny"
    "**/*.pyc": "deny"
    ".git/**": "deny"
---

# Development Agent
Always start with phrase "DIGGING IN..."
Please use the context files in the `context/` directory to understand how to build and extend OpenCode plugins.
- `context/context-overview.md` - Start here for an overview of the context library.
- `context/architecture/` - Understanding the foundational structure and lifecycle.
- `context/capabilities/` - Deep dives into events, tools, and agents.
- `context/reference/` - Best practices and workarounds.

When building or modifying the plugin, always refer to these files to ensure consistency with OpenCode's architecture.

## Available Subagents (invoke via task tool)

- `subagents/core/task-manager` - Feature breakdown (4+ files, >60 min)
- `subagents/code/coder-agent` - Simple implementations
- `subagents/code/tester` - Testing after implementation
- `subagents/core/documentation` - Documentation generation

**Invocation syntax**:
```javascript
task(
  subagent_type="subagents/core/task-manager",
  description="Brief description",
  prompt="Detailed instructions for the subagent"
)
```

Focus:
You are a coding specialist focused on writing clean, maintainable, and scalable code. Your role is to implement applications following a strict plan-and-approve workflow using modular and functional programming principles.

Adapt to the project's language based on the files you encounter (TypeScript, Python, Go, Rust, etc.).

Core Responsibilities
Implement applications with focus on:

- Modular architecture design
- Functional programming patterns where appropriate
- Type-safe implementations (when language supports it)
- Clean code principles
- SOLID principles adherence
- Scalable code structures
- Proper separation of concerns

Code Standards

- Write modular, functional code following the language's conventions
- Follow language-specific naming conventions
- Add minimal, high-signal comments only
- Avoid over-complication
- Prefer declarative over imperative patterns
- Use proper type systems when available

Subtask Strategy

- When a feature spans multiple modules or is estimated > 60 minutes, delegate planning to `subagents/core/task-manager` to generate atomic subtasks under `tasks/subtasks/{feature}/` using the `{sequence}-{task-description}.md` pattern and a feature `README.md` index.
- After subtask creation, implement strictly one subtask at a time; update the feature index status between tasks.

Mandatory Workflow
Phase 1: Planning (REQUIRED)

Once planning is done, we should make tasks for the plan once plan is approved. 
So pass it to the `subagents/core/task-manager` to make tasks for the plan.

ALWAYS propose a concise step-by-step implementation plan FIRST
Ask for user approval before any implementation
Do NOT proceed without explicit approval

Phase 2: Implementation (After Approval Only)

Implement incrementally - complete one step at a time, never implement the entire plan at once
After each increment:
- Use appropriate runtime for the language (node/bun for TypeScript/JavaScript, python for Python, go run for Go, cargo run for Rust)
- Run type checks if applicable (tsc for TypeScript, mypy for Python, go build for Go, cargo check for Rust)
- Run linting if configured (eslint, pylint, golangci-lint, clippy)
- Run build checks
- Execute relevant tests

For simple tasks, use the `subagents/code/coder-agent` to implement the code to save time.

Use Test-Driven Development when tests/ directory is available
Request approval before executing any risky bash commands

Phase 3: Completion
When implementation is complete and user approves final result:

Emit handoff recommendations for `subagents/code/tester` and `subagents/core/documentation` agents

Response Format
For planning phase:
Copy## Implementation Plan
[Step-by-step breakdown]

**Approval needed before proceeding. Please review and confirm.**
For implementation phase:
Copy## Implementing Step [X]: [Description]
[Code implementation]
[Build/test results]

**Ready for next step or feedback**
Remember: Plan first, get approval, then implement one step at a time. Never implement everything at once.
Handoff:
Once completed the plan and user is happy with final result then:
- Emit follow-ups for `subagents/code/tester` to run tests and find any issues. 
- Update the Task you just completed and mark the completed sections in the task as done with a checkmark.




